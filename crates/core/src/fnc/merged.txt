use http::HeaderMap;
use reblessive::tree::Stk;
use std::collections::BTreeMap;

use crate::{
	api::{body::ApiBody, invocation::ApiInvocation, method::Method},
	ctx::Context,
	dbs::{capabilities::ExperimentalTarget, Options},
	err::Error,
	sql::{statements::FindApi, Object, Value},
};

pub async fn invoke(
	(stk, ctx, opt): (&mut Stk, &Context, &Options),
	(path, opts): (String, Option<Object>),
) -> Result<Value, Error> {
	if !ctx.get_capabilities().allows_experimental(&ExperimentalTarget::DefineApi) {
		return Err(Error::InvalidFunction {
			name: "api::invoke".to_string(),
			message: "Experimental feature is disabled".to_string(),
		});
	}

	let (body, method, query, headers) = if let Some(opts) = opts {
		let body = match opts.get("body") {
			Some(v) => v.to_owned(),
			_ => Default::default(),
		};

		let method = if let Some(v) = opts.get("method") {
			Method::try_from(v)?
		} else {
			Method::Get
		};

		let query: BTreeMap<String, String> = if let Some(v) = opts.get("query") {
			v.to_owned().convert_to_object()?.try_into()?
		} else {
			Default::default()
		};

		let headers: HeaderMap = if let Some(v) = opts.get("headers") {
			v.to_owned().convert_to_object()?.try_into()?
		} else {
			Default::default()
		};

		(body, method, query, headers)
	} else {
		(Default::default(), Method::Get, Default::default(), Default::default())
	};

	let ns = opt.ns()?;
	let db = opt.db()?;
	let apis = ctx.tx().all_db_apis(ns, db).await?;
	let segments: Vec<&str> = path.split('/').filter(|x| !x.is_empty()).collect();

	if let Some((api, params)) = apis.as_ref().find_api(segments, method) {
		let invocation = ApiInvocation {
			params,
			method,
			query,
			headers,
		};

		match invocation.invoke_with_context(stk, ctx, opt, api, ApiBody::from_value(body)).await {
			Ok(Some(v)) => v.0.try_into(),
			Err(e) => Err(e),
			_ => Ok(Value::None),
		}
	} else {
		Ok(Value::None)
	}
}
use crate::err::Error;
use crate::sql::value::Value;
use crate::sql::{
	Array, Bytes, Bytesize, Closure, Datetime, Duration, File, Geometry, Kind, Number, Object,
	Regex, Strand, Thing, Uuid,
};
use std::vec::IntoIter;

/// Implemented by types that are commonly used, in a certain way, as arguments.
pub trait FromArg: Sized {
	fn from_arg(arg: Value) -> Result<Self, Error>;
}

impl FromArg for Value {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		Ok(arg)
	}
}

impl FromArg for bool {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_bool()
	}
}

impl FromArg for Closure {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_function()
	}
}

impl FromArg for File {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_file()
	}
}

impl FromArg for Regex {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_regex()
	}
}

impl FromArg for String {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_string()
	}
}

impl FromArg for Strand {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_strand()
	}
}

impl FromArg for Number {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_number()
	}
}

impl FromArg for Datetime {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_datetime()
	}
}

impl FromArg for Duration {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_duration()
	}
}

impl FromArg for Bytesize {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		Bytesize::parse(arg.coerce_to_string()?)
	}
}

impl FromArg for Geometry {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_geometry()
	}
}

impl FromArg for Thing {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_record()
	}
}

impl FromArg for Array {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_array()
	}
}

impl FromArg for Object {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_object()
	}
}

impl FromArg for Bytes {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_bytes()
	}
}

impl FromArg for i64 {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_i64()
	}
}

impl FromArg for u64 {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_u64()
	}
}

impl FromArg for f64 {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_f64()
	}
}

impl FromArg for isize {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		Ok(arg.coerce_to_i64()? as isize)
	}
}

impl FromArg for usize {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		Ok(arg.coerce_to_u64()? as usize)
	}
}

impl FromArg for Uuid {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_uuid()
	}
}

impl FromArg for Vec<String> {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_array_type(&Kind::String)?.into_iter().map(Value::try_into).collect()
	}
}

impl FromArg for Vec<Number> {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_array_type(&Kind::Number)?.into_iter().map(Value::try_into).collect()
	}
}

impl FromArg for Vec<Datetime> {
	fn from_arg(arg: Value) -> Result<Self, Error> {
		arg.coerce_to_array_type(&Kind::Datetime)?.into_iter().map(Value::try_into).collect()
	}
}

pub trait FromArgs: Sized {
	/// Convert a collection of argument values into a certain argument format, failing if there are
	/// too many or too few arguments, or if one of the arguments could not be converted.
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error>;
}

// Take ownership of the raw arguments collection, and assume responsibility of validating the
// number of arguments and converting them as necessary.
impl FromArgs for Vec<Value> {
	fn from_args(_name: &str, args: Vec<Value>) -> Result<Self, Error> {
		Ok(args)
	}
}

impl FromArgs for Vec<Array> {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		args.into_iter()
			.enumerate()
			.map(|(i, arg)| {
				arg.coerce_to_array_type(&Kind::Any).map_err(|e| Error::InvalidArguments {
					name: name.to_owned(),
					message: format!("Argument {} was the wrong type. {e}", i + 1),
				})
			})
			.collect()
	}
}

/// Some functions take a fixed number of arguments.
/// The len must match the number of type idents that follow.
macro_rules! impl_tuple {
	($len:expr, $( $T:ident ),*) => {
		impl<$($T:FromArg),*> FromArgs for ($($T,)*) {
			#[allow(non_snake_case)]
			fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
				let [$($T),*]: [Value; $len] = args.try_into().map_err(|_| Error::InvalidArguments {
					name: name.to_owned(),
					// This match will be optimized away.
					message: match $len {
						0 => String::from("Expected no arguments."),
						1 => String::from("Expected 1 argument."),
						_ => format!("Expected {} arguments.", $len),
					}
				})?;
				#[allow(unused_mut, unused_variables)]
				let mut i = 0;
				Ok((
					$({
						i += 1;
						$T::from_arg($T).map_err(|e| Error::InvalidArguments {
							name: name.to_owned(),
							message: format!("Argument {i} was the wrong type. {e}"),
						})?
					},)*
				))
			}
		}
	}
}

// It is possible to add larger sequences to support higher quantities of fixed arguments.
impl_tuple!(0,);
impl_tuple!(1, A);
impl_tuple!(2, A, B);
impl_tuple!(3, A, B, C);
impl_tuple!(4, A, B, C, D);

// Some functions take a single, optional argument, or no arguments at all.
impl<A: FromArg> FromArgs for (Option<A>,) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 0 or 1 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();
		// Process the first function argument
		let a = match args.next() {
			Some(a) => Some(A::from_arg(a).map_err(|e| Error::InvalidArguments {
				name: name.to_owned(),
				message: format!("Argument 1 was the wrong type. {e}"),
			})?),
			None => None,
		};
		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a,))
	}
}

// Some functions take 1 or 2 arguments, so the second argument is optional.
impl<A: FromArg, B: FromArg> FromArgs for (A, Option<B>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 1 or 2 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();
		// Process the first argument
		let a = A::from_arg(args.next().ok_or_else(err)?).map_err(|e| Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Argument 1 was the wrong type. {e}"),
		})?;
		let b = match args.next() {
			Some(b) => Some(B::from_arg(b)?),
			None => None,
		};
		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b))
	}
}

// Some functions take 4 arguments, with the 3rd and 4th being optional.
impl<A: FromArg, B: FromArg, C: FromArg, D: FromArg> FromArgs for (A, B, Option<C>, Option<D>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 2, 3 or 4 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();
		// Process the first argument
		let a = A::from_arg(args.next().ok_or_else(err)?).map_err(|e| Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Argument 1 was the wrong type. {e}"),
		})?;
		let b = B::from_arg(args.next().ok_or_else(err)?).map_err(|e| Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Argument 2 was the wrong type. {e}"),
		})?;
		let c = match args.next() {
			Some(c) => Some(C::from_arg(c)?),
			None => None,
		};
		let d = match args.next() {
			Some(d) => Some(D::from_arg(d)?),
			None => None,
		};
		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b, c, d))
	}
}

#[inline]
fn get_arg<T: FromArg, E: Fn() -> Error>(
	name: &str,
	pos: usize,
	args: &mut IntoIter<Value>,
	err: E,
) -> Result<T, Error> {
	T::from_arg(args.next().ok_or_else(err)?).map_err(|e| Error::InvalidArguments {
		name: name.to_owned(),
		message: format!("Argument {pos} was the wrong type. {e}"),
	})
}

#[inline]
fn get_opt_arg<T: FromArg>(
	name: &str,
	pos: usize,
	args: &mut IntoIter<Value>,
) -> Result<Option<T>, Error> {
	Ok(match args.next() {
		Some(v) => Some(T::from_arg(v).map_err(|e| Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Argument {pos} was the wrong type. {e}"),
		})?),
		None => None,
	})
}

// Some functions take 2 or 3 arguments, so the third argument is optional.
impl<A: FromArg, B: FromArg, C: FromArg> FromArgs for (A, B, Option<C>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 2 or 3 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();

		let a: A = get_arg(name, 1, &mut args, err)?;
		let b: B = get_arg(name, 2, &mut args, err)?;
		let c: Option<C> = get_opt_arg(name, 3, &mut args)?;

		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b, c))
	}
}

// Some functions take 3 or 4 arguments, so the fourth argument is optional.
impl<A: FromArg, B: FromArg, C: FromArg, D: FromArg> FromArgs for (A, B, C, Option<D>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 3 or 4 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();

		let a: A = get_arg(name, 1, &mut args, err)?;
		let b: B = get_arg(name, 2, &mut args, err)?;
		let c: C = get_arg(name, 3, &mut args, err)?;
		let d: Option<D> = get_opt_arg(name, 4, &mut args)?;

		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b, c, d))
	}
}

// Some functions take 0, 1, or 2 arguments, so both arguments are optional.
// It is safe to assume that, if the first argument is None, the second argument will also be None.
impl<A: FromArg, B: FromArg> FromArgs for (Option<A>, Option<B>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 0, 1, or 2 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();

		let a: Option<A> = get_opt_arg(name, 1, &mut args)?;
		let b: Option<B> = get_opt_arg(name, 2, &mut args)?;

		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b))
	}
}

// Some functions optionally take 2 arguments, or don't take any at all.
impl<A: FromArg, B: FromArg> FromArgs for (Option<(A, B)>,) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 0 or 2 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();

		let a: Option<A> = get_opt_arg(name, 1, &mut args)?;
		let b: Option<B> = get_opt_arg(name, 2, &mut args)?;

		// Process additional function arguments
		if a.is_some() != b.is_some() || args.next().is_some() {
			// One argument, or too many arguments
			return Err(err());
		}
		Ok((a.zip(b),))
	}
}

// Some functions take 1, 2, or 3 arguments. It is safe to assume that, if the second argument is
// None, the third argument will also be None.
impl<A: FromArg, B: FromArg, C: FromArg> FromArgs for (A, Option<B>, Option<C>) {
	fn from_args(name: &str, args: Vec<Value>) -> Result<Self, Error> {
		let err = || Error::InvalidArguments {
			name: name.to_owned(),
			message: String::from("Expected 1, 2, or 3 arguments."),
		};
		// Process the function arguments
		let mut args = args.into_iter();

		let a: A = get_arg(name, 1, &mut args, err)?;
		let b: Option<B> = get_opt_arg(name, 2, &mut args)?;
		let c: Option<C> = get_opt_arg(name, 3, &mut args)?;

		// Process additional function arguments
		if args.next().is_some() {
			// Too many arguments
			return Err(err());
		}
		Ok((a, b, c))
	}
}
use crate::cnf::GENERATION_ALLOCATION_LIMIT;
use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::sql::array::Array;
use crate::sql::array::Clump;
use crate::sql::array::Combine;
use crate::sql::array::Complement;
use crate::sql::array::Difference;
use crate::sql::array::Flatten;
use crate::sql::array::Intersect;
use crate::sql::array::Matches;
use crate::sql::array::Transpose;
use crate::sql::array::Union;
use crate::sql::array::Uniq;
use crate::sql::array::Windows;
use crate::sql::value::Value;
use crate::sql::Closure;
use crate::sql::FlowResultExt as _;
use crate::sql::Function;
use rand::prelude::SliceRandom;
use reblessive::tree::Stk;
use std::cmp::Ordering;
use std::mem::size_of_val;

/// Returns an error if an array of this length is too much to allocate.
fn limit(name: &str, n: usize) -> Result<(), Error> {
	if n > *GENERATION_ALLOCATION_LIMIT {
		Err(Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Output must not exceed {} bytes.", *GENERATION_ALLOCATION_LIMIT),
		})
	} else {
		Ok(())
	}
}

pub fn add((mut array, value): (Array, Value)) -> Result<Value, Error> {
	match value {
		Value::Array(value) => {
			for v in value.0 {
				if !array.0.iter().any(|x| *x == v) {
					array.0.push(v)
				}
			}
			Ok(array.into())
		}
		value => {
			if !array.0.iter().any(|x| *x == value) {
				array.0.push(value)
			}
			Ok(array.into())
		}
	}
}

pub async fn all(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, check): (Array, Option<Value>),
) -> Result<Value, Error> {
	Ok(match check {
		Some(closure) if closure.is_closure() => {
			if let Some(opt) = opt {
				for arg in array.into_iter() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						continue;
					} else {
						return Ok(Value::Bool(false));
					}
				}
				Value::Bool(true)
			} else {
				Value::None
			}
		}
		Some(value) => array.iter().all(|v: &Value| *v == value).into(),
		None => array.iter().all(Value::is_truthy).into(),
	})
}

pub async fn any(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, check): (Array, Option<Value>),
) -> Result<Value, Error> {
	Ok(match check {
		Some(closure) if closure.is_closure() => {
			if let Some(opt) = opt {
				for arg in array.into_iter() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						return Ok(Value::Bool(true));
					} else {
						continue;
					}
				}
				Value::Bool(false)
			} else {
				Value::None
			}
		}
		Some(value) => array.iter().any(|v: &Value| *v == value).into(),
		None => array.iter().any(Value::is_truthy).into(),
	})
}

pub fn append((mut array, value): (Array, Value)) -> Result<Value, Error> {
	array.push(value);
	Ok(array.into())
}

pub fn at((array, i): (Array, i64)) -> Result<Value, Error> {
	let mut idx = i as usize;
	if i < 0 {
		idx = (array.len() as i64 + i) as usize;
	}
	Ok(array.get(idx).cloned().unwrap_or_default())
}

pub fn boolean_and((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let longest_length = lh.len().max(rh.len());
	let mut results = Array::with_capacity(longest_length);
	for i in 0..longest_length {
		let lhv = lh.get(i);
		let rhv = rh.get(i);
		results
			.push((lhv.is_some_and(Value::is_truthy) && rhv.is_some_and(Value::is_truthy)).into());
	}
	Ok(results.into())
}

pub fn boolean_not((mut array,): (Array,)) -> Result<Value, Error> {
	array.iter_mut().for_each(|v| *v = (!v.is_truthy()).into());
	Ok(array.into())
}

pub fn boolean_or((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let longest_length = lh.len().max(rh.len());
	let mut results = Array::with_capacity(longest_length);
	for i in 0..longest_length {
		let lhv = lh.get(i);
		let rhv = rh.get(i);
		results
			.push((lhv.is_some_and(Value::is_truthy) || rhv.is_some_and(Value::is_truthy)).into());
	}
	Ok(results.into())
}

pub fn boolean_xor((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let longest_length = lh.len().max(rh.len());
	let mut results = Array::with_capacity(longest_length);
	for i in 0..longest_length {
		let lhv = lh.get(i);
		let rhv = rh.get(i);
		results
			.push((lhv.is_some_and(Value::is_truthy) ^ rhv.is_some_and(Value::is_truthy)).into());
	}
	Ok(results.into())
}

pub fn clump((array, clump_size): (Array, i64)) -> Result<Value, Error> {
	let clump_size = clump_size.max(0) as usize;
	Ok(array.clump(clump_size)?.into())
}

pub fn combine((array, other): (Array, Array)) -> Result<Value, Error> {
	Ok(array.combine(other).into())
}

pub fn complement((array, other): (Array, Array)) -> Result<Value, Error> {
	Ok(array.complement(other).into())
}

pub fn concat(mut arrays: Vec<Array>) -> Result<Value, Error> {
	let len = match arrays.iter().map(Array::len).reduce(|c, v| c + v) {
		None => Err(Error::InvalidArguments {
			name: String::from("array::concat"),
			message: String::from("Expected at least one argument"),
		}),
		Some(l) => Ok(l),
	}?;
	let mut arr = Array::with_capacity(len);
	arrays.iter_mut().for_each(|val| {
		arr.append(val);
	});
	Ok(arr.into())
}

pub fn difference((array, other): (Array, Array)) -> Result<Value, Error> {
	Ok(array.difference(other).into())
}

pub fn distinct((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.uniq().into())
}

pub fn fill(
	(mut array, value, start, end): (Array, Value, Option<isize>, Option<isize>),
) -> Result<Value, Error> {
	let len = array.len();

	let start = start.unwrap_or(0);
	let start = if start < 0 {
		len.saturating_sub((-start) as usize)
	} else {
		(start as usize).min(len)
	};

	let end = end.unwrap_or(len as isize);
	let end = if end < 0 {
		len.saturating_sub((-end) as usize)
	} else {
		(end as usize).min(len)
	};

	array[start..end].fill(value);

	Ok(array.into())
}

pub async fn filter(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, check): (Array, Value),
) -> Result<Value, Error> {
	Ok(match check {
		closure if closure.is_closure() => {
			if let Some(opt) = opt {
				let mut res = Vec::with_capacity(array.len());
				for arg in array.into_iter() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg.clone()], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						res.push(arg)
					}
				}
				Value::from(res)
			} else {
				Value::None
			}
		}
		value => array.into_iter().filter(|v: &Value| *v == value).collect::<Vec<_>>().into(),
	})
}

pub async fn filter_index(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, value): (Array, Value),
) -> Result<Value, Error> {
	Ok(match value {
		closure if closure.is_closure() => {
			if let Some(opt) = opt {
				let mut res = Vec::with_capacity(array.len());
				for (i, arg) in array.into_iter().enumerate() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg, i.into()], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						res.push(i);
					}
				}
				Value::from(res)
			} else {
				Value::None
			}
		}
		value => array
			.iter()
			.enumerate()
			.filter_map(|(i, v)| {
				if *v == value {
					Some(Value::from(i))
				} else {
					None
				}
			})
			.collect::<Vec<_>>()
			.into(),
	})
}

pub async fn find(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, value): (Array, Value),
) -> Result<Value, Error> {
	Ok(match value {
		closure if closure.is_closure() => {
			if let Some(opt) = opt {
				for arg in array.into_iter() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg.clone()], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						return Ok(arg);
					}
				}
				Value::None
			} else {
				Value::None
			}
		}
		value => array.into_iter().find(|v: &Value| *v == value).into(),
	})
}

pub async fn find_index(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, value): (Array, Value),
) -> Result<Value, Error> {
	Ok(match value {
		closure if closure.is_closure() => {
			if let Some(opt) = opt {
				for (i, arg) in array.into_iter().enumerate() {
					// TODO: Don't clone the closure every time the function is called.
					let fnc = Function::Anonymous(closure.clone(), vec![arg, i.into()], true);
					if fnc.compute(stk, ctx, opt, doc).await.catch_return()?.is_truthy() {
						return Ok(i.into());
					}
				}
				Value::None
			} else {
				Value::None
			}
		}
		value => array
			.iter()
			.enumerate()
			.find_map(|(i, v)| {
				if *v == value {
					Some(Value::from(i))
				} else {
					None
				}
			})
			.into(),
	})
}

pub fn first((array,): (Array,)) -> Result<Value, Error> {
	if let [first, ..] = &array[0..] {
		Ok(first.to_owned())
	} else {
		Ok(Value::None)
	}
}

pub fn flatten((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.flatten().into())
}

pub async fn fold(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, init, mapper): (Array, Value, Closure),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		let mut accum = init;
		for (i, val) in array.into_iter().enumerate() {
			// TODO: Don't clone the closure every time the function is called.
			let fnc = Function::Anonymous(mapper.clone().into(), vec![accum, val, i.into()], true);
			accum = fnc.compute(stk, ctx, opt, doc).await.catch_return()?;
		}
		Ok(accum)
	} else {
		Ok(Value::None)
	}
}

pub fn group((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.flatten().uniq().into())
}

pub fn insert((mut array, value, index): (Array, Value, Option<i64>)) -> Result<Value, Error> {
	match index {
		Some(mut index) => {
			// Negative index means start from the back
			if index < 0 {
				index += array.len() as i64;
			}
			// Invalid index so return array unaltered
			if index > array.len() as i64 || index < 0 {
				return Ok(array.into());
			}
			// Insert the value into the array
			array.insert(index as usize, value);
			// Return the array
			Ok(array.into())
		}
		None => {
			array.push(value);
			Ok(array.into())
		}
	}
}

pub fn intersect((array, other): (Array, Array)) -> Result<Value, Error> {
	Ok(array.intersect(other).into())
}

pub fn is_empty((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.is_empty().into())
}

pub fn join((arr, sep): (Array, String)) -> Result<Value, Error> {
	Ok(arr.into_iter().map(Value::as_raw_string).collect::<Vec<_>>().join(&sep).into())
}

pub fn last((array,): (Array,)) -> Result<Value, Error> {
	if let [.., last] = &array[0..] {
		Ok(last.to_owned())
	} else {
		Ok(Value::None)
	}
}

pub fn len((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.len().into())
}

pub fn logical_and((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let mut result_arr = Array::with_capacity(lh.len().max(rh.len()));
	let mut iters = (lh.into_iter(), rh.into_iter());
	for (lhv, rhv) in std::iter::from_fn(|| {
		let r = (iters.0.next(), iters.1.next());
		if r.0.is_none() && r.1.is_none() {
			None
		} else {
			Some((r.0.unwrap_or(Value::Null), r.1.unwrap_or(Value::Null)))
		}
	}) {
		let truth = lhv.is_truthy() && rhv.is_truthy();
		let r = if lhv.is_truthy() == truth {
			lhv
		} else if rhv.is_truthy() == truth {
			rhv
		} else {
			truth.into()
		};
		result_arr.push(r);
	}
	Ok(result_arr.into())
}

pub fn logical_or((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let mut result_arr = Array::with_capacity(lh.len().max(rh.len()));
	let mut iters = (lh.into_iter(), rh.into_iter());
	for (lhv, rhv) in std::iter::from_fn(|| {
		let r = (iters.0.next(), iters.1.next());
		if r.0.is_none() && r.1.is_none() {
			None
		} else {
			Some((r.0.unwrap_or(Value::Null), r.1.unwrap_or(Value::Null)))
		}
	}) {
		let truth = lhv.is_truthy() || rhv.is_truthy();
		let r = if lhv.is_truthy() == truth {
			lhv
		} else if rhv.is_truthy() == truth {
			rhv
		} else {
			truth.into()
		};
		result_arr.push(r);
	}
	Ok(result_arr.into())
}

pub fn logical_xor((lh, rh): (Array, Array)) -> Result<Value, Error> {
	let mut result_arr = Array::with_capacity(lh.len().max(rh.len()));
	let mut iters = (lh.into_iter(), rh.into_iter());
	for (lhv, rhv) in std::iter::from_fn(|| {
		let r = (iters.0.next(), iters.1.next());
		if r.0.is_none() && r.1.is_none() {
			None
		} else {
			Some((r.0.unwrap_or(Value::Null), r.1.unwrap_or(Value::Null)))
		}
	}) {
		let truth = lhv.is_truthy() ^ rhv.is_truthy();
		let r = if lhv.is_truthy() == truth {
			lhv
		} else if rhv.is_truthy() == truth {
			rhv
		} else {
			truth.into()
		};
		result_arr.push(r);
	}
	Ok(result_arr.into())
}

pub async fn map(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, mapper): (Array, Closure),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		let mut res = Vec::with_capacity(array.len());
		for (i, arg) in array.into_iter().enumerate() {
			// TODO: Don't clone the closure every time the function is called.
			let fnc = Function::Anonymous(mapper.clone().into(), vec![arg, i.into()], true);
			res.push(fnc.compute(stk, ctx, opt, doc).await.catch_return()?);
		}
		Ok(res.into())
	} else {
		Ok(Value::None)
	}
}

pub fn matches((array, compare_val): (Array, Value)) -> Result<Value, Error> {
	Ok(array.matches(compare_val).into())
}

pub fn max((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.into_iter().max().unwrap_or_default())
}

pub fn min((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.into_iter().min().unwrap_or_default())
}

pub fn pop((mut array,): (Array,)) -> Result<Value, Error> {
	Ok(array.pop().into())
}

pub fn prepend((mut array, value): (Array, Value)) -> Result<Value, Error> {
	array.insert(0, value);
	Ok(array.into())
}

pub fn push((mut array, value): (Array, Value)) -> Result<Value, Error> {
	array.push(value);
	Ok(array.into())
}

pub fn range((start, count): (i64, i64)) -> Result<Value, Error> {
	if count < 0 {
		return Err(Error::InvalidArguments {
			name: String::from("array::range"),
			message: format!(
				"Argument 1 was the wrong type. Expected a positive number but found {count}"
			),
		});
	}

	if let Some(end) = start.checked_add(count - 1) {
		Ok(Array((start..=end).map(Value::from).collect::<Vec<_>>()).into())
	} else {
		Err(Error::InvalidArguments {
			name: String::from("array::range"),
			message: String::from("The range overflowed the maximum value for an integer"),
		})
	}
}

pub async fn reduce(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(array, mapper): (Array, Closure),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		match array.len() {
			0 => Ok(Value::None),
			1 => {
				let Some(val) = array.into_iter().next() else {
					return Err(Error::Unreachable(
						"Iterator should have an item at this point".into(),
					));
				};
				Ok(val)
			}
			_ => {
				// Get the first item
				let mut iter = array.into_iter();
				let Some(mut accum) = iter.next() else {
					return Ok(Value::None);
				};
				for (idx, val) in iter.enumerate() {
					let fnc = Function::Anonymous(
						mapper.clone().into(),
						vec![accum, val, idx.into()],
						true,
					);
					accum = fnc.compute(stk, ctx, opt, doc).await.catch_return()?;
				}
				Ok(accum)
			}
		}
	} else {
		Ok(Value::None)
	}
}

pub fn remove((mut array, mut index): (Array, i64)) -> Result<Value, Error> {
	// Negative index means start from the back
	if index < 0 {
		index += array.len() as i64;
	}
	// Invalid index so return array unaltered
	if index >= array.len() as i64 || index < 0 {
		return Ok(array.into());
	}
	// Remove the value from the array
	array.remove(index as usize);
	// Return the array
	Ok(array.into())
}

pub fn repeat((value, count): (Value, usize)) -> Result<Value, Error> {
	limit("array::repeat", size_of_val(&value).saturating_mul(count))?;
	Ok(Array(std::iter::repeat_n(value, count).collect()).into())
}

pub fn reverse((mut array,): (Array,)) -> Result<Value, Error> {
	array.reverse();
	Ok(array.into())
}

pub fn shuffle((mut array,): (Array,)) -> Result<Value, Error> {
	let mut rng = rand::thread_rng();
	array.shuffle(&mut rng);
	Ok(array.into())
}

pub fn slice((array, beg, lim): (Array, Option<isize>, Option<isize>)) -> Result<Value, Error> {
	let skip = match beg {
		Some(v) if v < 0 => array.len().saturating_sub(v.unsigned_abs()),
		Some(v) => v as usize,
		None => 0,
	};

	let take = match lim {
		Some(v) if v < 0 => array.len().saturating_sub(skip).saturating_sub(v.unsigned_abs()),
		Some(v) => v as usize,
		None => usize::MAX,
	};

	Ok(if skip > 0 || take < usize::MAX {
		array.into_iter().skip(skip).take(take).collect::<Vec<_>>().into()
	} else {
		array
	}
	.into())
}

fn sort_as_asc(order: &Option<Value>) -> bool {
	match order {
		Some(Value::Strand(s)) if s.as_str() == "asc" => true,
		Some(Value::Strand(s)) if s.as_str() == "desc" => false,
		Some(Value::Bool(true)) => true,
		Some(Value::Bool(false)) => false,
		_ => true,
	}
}

pub fn sort((mut array, order): (Array, Option<Value>)) -> Result<Value, Error> {
	if sort_as_asc(&order) {
		array.sort_unstable();
		Ok(array.into())
	} else {
		array.sort_unstable_by(|a, b| b.cmp(a));
		Ok(array.into())
	}
}

pub fn sort_natural((mut array, order): (Array, Option<Value>)) -> Result<Value, Error> {
	if sort_as_asc(&order) {
		array.sort_unstable_by(|a, b| a.natural_cmp(b).unwrap_or(Ordering::Equal));
		Ok(array.into())
	} else {
		array.sort_unstable_by(|a, b| b.natural_cmp(a).unwrap_or(Ordering::Equal));
		Ok(array.into())
	}
}

pub fn sort_lexical((mut array, order): (Array, Option<Value>)) -> Result<Value, Error> {
	if sort_as_asc(&order) {
		array.sort_unstable_by(|a, b| a.lexical_cmp(b).unwrap_or(Ordering::Equal));
		Ok(array.into())
	} else {
		array.sort_unstable_by(|a, b| b.lexical_cmp(a).unwrap_or(Ordering::Equal));
		Ok(array.into())
	}
}

pub fn sort_natural_lexical((mut array, order): (Array, Option<Value>)) -> Result<Value, Error> {
	if sort_as_asc(&order) {
		array.sort_unstable_by(|a, b| a.natural_lexical_cmp(b).unwrap_or(Ordering::Equal));
		Ok(array.into())
	} else {
		array.sort_unstable_by(|a, b| b.natural_lexical_cmp(a).unwrap_or(Ordering::Equal));
		Ok(array.into())
	}
}

pub fn swap((mut array, from, to): (Array, isize, isize)) -> Result<Value, Error> {
	let min = 0;
	let max = array.len();
	let negative_max = -(max as isize);

	let from = match from {
		from if from < negative_max || from >= max as isize => Err(Error::InvalidArguments {
			name: String::from("array::swap"),
			message: format!(
				"Argument 1 is out of range. Expected a number between {negative_max} and {max}"
			),
		}),
		from if negative_max <= from && from < min => Ok((from + max as isize) as usize),
		from => Ok(from as usize),
	}?;

	let to = match to {
		to if to < negative_max || to >= max as isize => Err(Error::InvalidArguments {
			name: String::from("array::swap"),
			message: format!(
				"Argument 2 is out of range. Expected a number between {negative_max} and {max}"
			),
		}),
		to if negative_max <= to && to < min => Ok((to + max as isize) as usize),
		to => Ok(to as usize),
	}?;

	array.swap(from, to);
	Ok(array.into())
}

pub fn transpose((array,): (Array,)) -> Result<Value, Error> {
	Ok(array.transpose().into())
}

pub fn union((array, other): (Array, Array)) -> Result<Value, Error> {
	Ok(array.union(other).into())
}

pub fn windows((array, window_size): (Array, i64)) -> Result<Value, Error> {
	let window_size = window_size.max(0) as usize;
	Ok(array.windows(window_size)?.into())
}

pub mod sort {

	use crate::err::Error;
	use crate::sql::array::Array;
	use crate::sql::value::Value;

	pub fn asc((mut array,): (Array,)) -> Result<Value, Error> {
		array.sort_unstable();
		Ok(array.into())
	}

	pub fn desc((mut array,): (Array,)) -> Result<Value, Error> {
		array.sort_unstable_by(|a, b| b.cmp(a));
		Ok(array.into())
	}
}

#[cfg(test)]
mod tests {
	use super::{at, first, join, last, slice};
	use crate::sql::{Array, Value};

	#[test]
	fn array_slice() {
		fn test(initial: &[u8], beg: Option<isize>, lim: Option<isize>, expected: &[u8]) {
			let initial_values =
				initial.iter().map(|n| Value::from(*n as i64)).collect::<Vec<_>>().into();
			let expected_values: Array =
				expected.iter().map(|n| Value::from(*n as i64)).collect::<Vec<_>>().into();
			assert_eq!(slice((initial_values, beg, lim)).unwrap(), expected_values.into());
		}

		let array = b"abcdefg";
		test(array, None, None, array);
		test(array, Some(2), None, &array[2..]);
		test(array, Some(2), Some(3), &array[2..5]);
		test(array, Some(2), Some(-1), b"cdef");
		test(array, Some(-2), None, b"fg");
		test(array, Some(-4), Some(2), b"de");
		test(array, Some(-4), Some(-1), b"def");
	}

	#[test]
	fn array_join() {
		fn test(arr: Array, sep: &str, expected: &str) {
			assert_eq!(join((arr, sep.to_string())).unwrap(), expected.into());
		}

		test(Vec::<Value>::new().into(), ",", "");
		test(vec!["hello"].into(), ",", "hello");
		test(vec!["hello", "world"].into(), ",", "hello,world");
		test(vec!["again"; 512].into(), " and ", &vec!["again"; 512].join(" and "));
		test(
			vec![Value::from(true), Value::from(false), Value::from(true)].into(),
			" is ",
			"true is false is true",
		);
		test(
			vec![Value::from(3.56), Value::from(2.72), Value::from(1.61)].into(),
			" is not ",
			"3.56f is not 2.72f is not 1.61f",
		);
	}

	#[test]
	fn array_first() {
		fn test(arr: Array, expected: Value) {
			assert_eq!(first((arr,)).unwrap(), expected);
		}

		test(vec!["hello", "world"].into(), "hello".into());
		test(Array::new(), Value::None);
	}

	#[test]
	fn array_last() {
		fn test(arr: Array, expected: Value) {
			assert_eq!(last((arr,)).unwrap(), expected);
		}

		test(vec!["hello", "world"].into(), "world".into());
		test(Array::new(), Value::None);
	}

	#[test]
	fn array_at() {
		fn test(arr: Array, i: i64, expected: Value) {
			assert_eq!(at((arr, i)).unwrap(), expected);
		}
		test(vec!["hello", "world"].into(), -2, "hello".into());
		test(vec!["hello", "world"].into(), -3, Value::None);
	}
}
use crate::err::Error;
use crate::sql::{Bytes, Value};

pub fn len((bytes,): (Bytes,)) -> Result<Value, Error> {
	Ok(bytes.len().into())
}
use crate::err::Error;
use crate::sql::value::Value;

pub fn count((arg,): (Option<Value>,)) -> Result<Value, Error> {
	Ok(arg
		.map(|val| match val {
			Value::Array(v) => v.iter().filter(|v| v.is_truthy()).count().into(),
			v => (v.is_truthy() as i64).into(),
		})
		.unwrap_or_else(|| 1.into()))
}
use crate::err::Error;
use crate::sql::value::Value;
use md5::Digest;
use md5::Md5;
use sha1::Sha1;
use sha2::Sha256;
use sha2::Sha512;

pub fn blake3((arg,): (String,)) -> Result<Value, Error> {
	Ok(blake3::hash(arg.as_bytes()).to_string().into())
}

pub fn md5((arg,): (String,)) -> Result<Value, Error> {
	let mut hasher = Md5::new();
	hasher.update(arg.as_str());
	let val = hasher.finalize();
	let val = format!("{val:x}");
	Ok(val.into())
}

pub fn sha1((arg,): (String,)) -> Result<Value, Error> {
	let mut hasher = Sha1::new();
	hasher.update(arg.as_str());
	let val = hasher.finalize();
	let val = format!("{val:x}");
	Ok(val.into())
}

pub fn sha256((arg,): (String,)) -> Result<Value, Error> {
	let mut hasher = Sha256::new();
	hasher.update(arg.as_str());
	let val = hasher.finalize();
	let val = format!("{val:x}");
	Ok(val.into())
}

pub fn sha512((arg,): (String,)) -> Result<Value, Error> {
	let mut hasher = Sha512::new();
	hasher.update(arg.as_str());
	let val = hasher.finalize();
	let val = format!("{val:x}");
	Ok(val.into())
}

/// Allowed to cost this much more than default setting for each hash function.
const COST_ALLOWANCE: u32 = 4;

/// Like verify_password, but takes a closure to determine whether the cost of performing the
/// operation is not too high.
macro_rules! bounded_verify_password {
	($algo: ident, $instance: expr, $password: expr, $hash: expr, $bound: expr) => {
		if let (Some(salt), Some(expected_output)) = (&$hash.salt, &$hash.hash) {
			if let Some(params) =
				<$algo as PasswordHasher>::Params::try_from($hash).ok().filter($bound)
			{
				if let Ok(computed_hash) = $instance.hash_password_customized(
					$password.as_ref(),
					Some($hash.algorithm),
					$hash.version,
					params,
					*salt,
				) {
					if let Some(computed_output) = &computed_hash.hash {
						expected_output == computed_output
					} else {
						false
					}
				} else {
					false
				}
			} else {
				false
			}
		} else {
			false
		}
	};

	($algo: ident, $password: expr, $hash: expr, $bound: expr) => {
		bounded_verify_password!($algo, $algo::default(), $password, $hash, $bound)
	};
}

pub mod argon2 {

	use super::COST_ALLOWANCE;
	use crate::err::Error;
	use crate::sql::value::Value;
	use argon2::{
		password_hash::{PasswordHash, PasswordHasher, SaltString},
		Argon2,
	};
	use rand::rngs::OsRng;

	pub fn cmp((hash, pass): (String, String)) -> Result<Value, Error> {
		type Params<'a> = <Argon2<'a> as PasswordHasher>::Params;
		Ok(PasswordHash::new(&hash)
			.ok()
			.filter(|test| {
				bounded_verify_password!(Argon2, pass, test, |params: &Params| {
					params.m_cost() <= Params::DEFAULT_M_COST.saturating_mul(COST_ALLOWANCE)
						&& params.t_cost() <= Params::DEFAULT_T_COST.saturating_mul(COST_ALLOWANCE)
						&& params.p_cost() <= Params::DEFAULT_P_COST.saturating_mul(COST_ALLOWANCE)
				})
			})
			.is_some()
			.into())
	}

	pub fn gen((pass,): (String,)) -> Result<Value, Error> {
		let algo = Argon2::default();
		let salt = SaltString::generate(&mut OsRng);
		let hash = algo.hash_password(pass.as_ref(), &salt).unwrap().to_string();
		Ok(hash.into())
	}
}

pub mod bcrypt {

	use crate::err::Error;
	use crate::fnc::crypto::COST_ALLOWANCE;
	use crate::sql::value::Value;
	use bcrypt::HashParts;
	use std::str::FromStr;

	pub fn cmp((hash, pass): (String, String)) -> Result<Value, Error> {
		let parts = match HashParts::from_str(&hash) {
			Ok(parts) => parts,
			Err(_) => return Ok(Value::Bool(false)),
		};
		// Note: Bcrypt cost is exponential, so add the cost allowance as opposed to multiplying.
		Ok(if parts.get_cost() > bcrypt::DEFAULT_COST.saturating_add(COST_ALLOWANCE) {
			// Too expensive to compute.
			Value::Bool(false)
		} else {
			// FIXME: If base64 dependency is added, can avoid parsing the HashParts twice, once
			// above and once in verity, by using bcrypt::bcrypt.
			bcrypt::verify(pass, &hash).unwrap_or(false).into()
		})
	}

	pub fn gen((pass,): (String,)) -> Result<Value, Error> {
		let hash = bcrypt::hash(pass, bcrypt::DEFAULT_COST).unwrap();
		Ok(hash.into())
	}
}

pub mod pbkdf2 {

	use super::COST_ALLOWANCE;
	use crate::err::Error;
	use crate::sql::value::Value;
	use pbkdf2::{
		password_hash::{PasswordHash, PasswordHasher, SaltString},
		Pbkdf2,
	};
	use rand::rngs::OsRng;

	pub fn cmp((hash, pass): (String, String)) -> Result<Value, Error> {
		type Params = <Pbkdf2 as PasswordHasher>::Params;
		Ok(PasswordHash::new(&hash)
			.ok()
			.filter(|test| {
				bounded_verify_password!(Pbkdf2, Pbkdf2, pass, test, |params: &Params| {
					params.rounds <= Params::default().rounds.saturating_mul(COST_ALLOWANCE)
						&& params.output_length
							<= Params::default()
								.output_length
								.saturating_mul(COST_ALLOWANCE as usize)
				})
			})
			.is_some()
			.into())
	}

	pub fn gen((pass,): (String,)) -> Result<Value, Error> {
		let salt = SaltString::generate(&mut OsRng);
		let hash = Pbkdf2.hash_password(pass.as_ref(), &salt).unwrap().to_string();
		Ok(hash.into())
	}
}

pub mod scrypt {

	use crate::err::Error;
	use crate::sql::value::Value;
	use rand::rngs::OsRng;
	use scrypt::{
		password_hash::{PasswordHash, PasswordHasher, SaltString},
		Scrypt,
	};

	pub fn cmp((hash, pass): (String, String)) -> Result<Value, Error> {
		type Params = <Scrypt as PasswordHasher>::Params;
		Ok(PasswordHash::new(&hash)
			.ok()
			.filter(|test| {
				bounded_verify_password!(Scrypt, Scrypt, pass, test, |params: &Params| {
					// Scrypt is slow, use lower cost allowance.
					// Also note that the log_n parameter behaves exponentially, so add instead
					// of multiplying.
					params.log_n() <= Params::default().log_n().saturating_add(2)
						&& params.r() <= Params::default().r().saturating_mul(2)
						&& params.p() <= Params::default().p().saturating_mul(4)
				})
			})
			.is_some()
			.into())
	}

	pub fn gen((pass,): (String,)) -> Result<Value, Error> {
		let salt = SaltString::generate(&mut OsRng);
		let hash = Scrypt.hash_password(pass.as_ref(), &salt).unwrap().to_string();
		Ok(hash.into())
	}
}
use crate::err::Error;
use crate::sql::duration::Duration;
use crate::sql::value::Value;

pub fn days((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.days().into())
}

pub fn hours((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.hours().into())
}

pub fn micros((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.micros().into())
}

pub fn millis((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.millis().into())
}

pub fn mins((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.mins().into())
}

pub fn nanos((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.nanos().into())
}

pub fn secs((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.secs().into())
}

pub fn weeks((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.weeks().into())
}

pub fn years((val,): (Duration,)) -> Result<Value, Error> {
	Ok(val.years().into())
}

pub mod from {

	use crate::err::Error;
	use crate::sql::duration::Duration;
	use crate::sql::value::Value;

	pub fn days((val,): (u64,)) -> Result<Value, Error> {
		Duration::from_days(val)
			.map(|x| x.into())
			.ok_or_else(|| Error::ArithmeticOverflow(format!("duration::from::days({val})")))
	}

	pub fn hours((val,): (u64,)) -> Result<Value, Error> {
		Duration::from_hours(val)
			.map(|x| x.into())
			.ok_or_else(|| Error::ArithmeticOverflow(format!("duration::from::hours({val})")))
	}

	pub fn micros((val,): (u64,)) -> Result<Value, Error> {
		Ok(Duration::from_micros(val).into())
	}

	pub fn millis((val,): (u64,)) -> Result<Value, Error> {
		Ok(Duration::from_millis(val).into())
	}

	pub fn mins((val,): (u64,)) -> Result<Value, Error> {
		Duration::from_mins(val)
			.map(|x| x.into())
			.ok_or_else(|| Error::ArithmeticOverflow(format!("duration::from::mins({val})")))
	}

	pub fn nanos((val,): (u64,)) -> Result<Value, Error> {
		Ok(Duration::from_nanos(val).into())
	}

	pub fn secs((val,): (u64,)) -> Result<Value, Error> {
		Ok(Duration::from_secs(val).into())
	}

	pub fn weeks((val,): (u64,)) -> Result<Value, Error> {
		Duration::from_weeks(val)
			.map(|x| x.into())
			.ok_or_else(|| Error::ArithmeticOverflow(format!("duration::from::weeks({val})")))
	}
}
pub mod base64 {
	use crate::err::Error;
	use crate::sql::{Bytes, Value};
	use base64::{engine::general_purpose::STANDARD_NO_PAD, Engine};

	pub fn encode((arg,): (Bytes,)) -> Result<Value, Error> {
		Ok(Value::from(STANDARD_NO_PAD.encode(&*arg)))
	}

	pub fn decode((arg,): (String,)) -> Result<Value, Error> {
		Ok(Value::from(Bytes(STANDARD_NO_PAD.decode(arg).map_err(|_| {
			Error::InvalidArguments {
				name: "encoding::base64::decode".to_owned(),
				message: "invalid base64".to_owned(),
			}
		})?)))
	}
}
use reblessive::tree::Stk;

use crate::{
	buc::{store::Key, FileController},
	ctx::Context,
	dbs::Options,
	err::Error,
	sql::{File, Value},
};

use super::CursorDoc;

pub async fn put(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file, value): (File, Value),
) -> Result<Value, Error> {
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.put(value).await?;

	Ok(Value::None)
}

pub async fn get(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file,): (File,),
) -> Result<Value, Error> {
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	let res = controller.get().await?;
	Ok(res.map(Value::Bytes).unwrap_or_default())
}

pub async fn head(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file,): (File,),
) -> Result<Value, Error> {
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	let res = controller.head().await?;
	Ok(res.map(Into::into).unwrap_or_default())
}

pub async fn delete(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file,): (File,),
) -> Result<Value, Error> {
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.delete().await?;

	Ok(Value::None)
}

pub async fn copy(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file, target): (File, String),
) -> Result<Value, Error> {
	let target = Key::from(target);
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.copy(target).await?;

	Ok(Value::None)
}

pub async fn copy_if_not_exists(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file, target): (File, String),
) -> Result<Value, Error> {
	let target = Key::from(target);
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.copy_if_not_exists(target).await?;

	Ok(Value::None)
}

pub async fn rename(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file, target): (File, String),
) -> Result<Value, Error> {
	let target = Key::from(target);
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.rename(target).await?;

	Ok(Value::None)
}

pub async fn rename_if_not_exists(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file, target): (File, String),
) -> Result<Value, Error> {
	let target = Key::from(target);
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	controller.rename_if_not_exists(target).await?;

	Ok(Value::None)
}

pub async fn exists(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(file,): (File,),
) -> Result<Value, Error> {
	let mut controller = FileController::from_file(stk, ctx, opt, doc, &file).await?;
	let exists = controller.exists().await?;

	Ok(Value::Bool(exists))
}
use crate::err::Error;
use crate::sql::geometry::Geometry;
use crate::sql::value::Value;
use geo::algorithm::bearing::HaversineBearing;
use geo::algorithm::centroid::Centroid;
use geo::algorithm::chamberlain_duquette_area::ChamberlainDuquetteArea;
use geo::algorithm::haversine_distance::HaversineDistance;

pub fn area((arg,): (Geometry,)) -> Result<Value, Error> {
	match arg {
		Geometry::Point(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::Line(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::Polygon(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::MultiPoint(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::MultiLine(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::MultiPolygon(v) => Ok(v.chamberlain_duquette_unsigned_area().into()),
		Geometry::Collection(v) => Ok(v
			.into_iter()
			.collect::<geo::Geometry<f64>>()
			.chamberlain_duquette_unsigned_area()
			.into()),
	}
}

pub fn bearing((v, w): (Geometry, Geometry)) -> Result<Value, Error> {
	Ok(match (v, w) {
		(Geometry::Point(v), Geometry::Point(w)) => v.haversine_bearing(w).into(),
		_ => Value::None,
	})
}

pub fn centroid((arg,): (Geometry,)) -> Result<Value, Error> {
	let centroid = match arg {
		Geometry::Point(v) => Some(v.centroid()),
		Geometry::Line(v) => v.centroid(),
		Geometry::Polygon(v) => v.centroid(),
		Geometry::MultiPoint(v) => v.centroid(),
		Geometry::MultiLine(v) => v.centroid(),
		Geometry::MultiPolygon(v) => v.centroid(),
		Geometry::Collection(v) => v.into_iter().collect::<geo::Geometry<f64>>().centroid(),
	};
	Ok(centroid.map(Into::into).unwrap_or(Value::None))
}

pub fn distance((v, w): (Geometry, Geometry)) -> Result<Value, Error> {
	Ok(match (v, w) {
		(Geometry::Point(v), Geometry::Point(w)) => v.haversine_distance(&w).into(),
		_ => Value::None,
	})
}

pub mod hash {

	use crate::err::Error;
	use crate::fnc::util::geo;
	use crate::sql::geometry::Geometry;
	use crate::sql::value::Value;

	pub fn encode((arg, len): (Geometry, Option<usize>)) -> Result<Value, Error> {
		let len = match len {
			Some(len) if (1..=12).contains(&len) => len,
			None => 12,
			_ => return Err(Error::InvalidArguments {
				name: String::from("geo::encode"),
				message: String::from("The second argument must be an integer greater than 0 and less than or equal to 12."),
			})
		};

		Ok(match arg {
			Geometry::Point(v) => geo::encode(v, len).into(),
			_ => Value::None,
		})
	}

	pub fn decode((arg,): (Value,)) -> Result<Value, Error> {
		match arg {
			Value::Strand(v) => Ok(geo::decode(v).into()),
			_ => Ok(Value::None),
		}
	}
}

pub mod is {

	use crate::err::Error;
	use crate::sql::geometry::Geometry;
	use crate::sql::value::Value;

	pub fn valid((arg,): (Geometry,)) -> Result<Value, Error> {
		Ok(arg.is_valid().into())
	}
}
use crate::ctx::Context;
use crate::err::Error;
use crate::sql::value::Value;

#[cfg(not(feature = "http"))]
pub async fn head(_: &Context, (_, _): (Value, Option<Value>)) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(not(feature = "http"))]
pub async fn get(_: &Context, (_, _): (Value, Option<Value>)) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(not(feature = "http"))]
pub async fn put(
	_: &Context,
	(_, _, _): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(not(feature = "http"))]
pub async fn post(
	_: &Context,
	(_, _, _): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(not(feature = "http"))]
pub async fn patch(
	_: &Context,
	(_, _, _): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(not(feature = "http"))]
pub async fn delete(_: &Context, (_, _): (Value, Option<Value>)) -> Result<Value, Error> {
	Err(Error::HttpDisabled)
}

#[cfg(feature = "http")]
fn try_as_uri(fn_name: &str, value: Value) -> Result<crate::sql::Strand, Error> {
	match value {
		// Pre-check URI.
		Value::Strand(uri) if crate::fnc::util::http::uri_is_valid(&uri) => Ok(uri),
		_ => Err(Error::InvalidArguments {
			name: fn_name.to_owned(),
			// Assumption is that URI is first argument.
			message: String::from("The first argument should be a string containing a valid URI."),
		}),
	}
}

#[cfg(feature = "http")]
fn try_as_opts(
	fn_name: &str,
	error_message: &str,
	value: Option<Value>,
) -> Result<Option<crate::sql::Object>, Error> {
	match value {
		Some(Value::Object(opts)) => Ok(Some(opts)),
		None => Ok(None),
		Some(_) => Err(Error::InvalidArguments {
			name: fn_name.to_owned(),
			message: error_message.to_owned(),
		}),
	}
}

#[cfg(feature = "http")]
pub async fn head(ctx: &Context, (uri, opts): (Value, Option<Value>)) -> Result<Value, Error> {
	let uri = try_as_uri("http::head", uri)?;
	let opts = try_as_opts("http::head", "The second argument should be an object.", opts)?;
	crate::fnc::util::http::head(ctx, uri, opts).await
}

#[cfg(feature = "http")]
pub async fn get(ctx: &Context, (uri, opts): (Value, Option<Value>)) -> Result<Value, Error> {
	let uri = try_as_uri("http::get", uri)?;
	let opts = try_as_opts("http::get", "The second argument should be an object.", opts)?;
	crate::fnc::util::http::get(ctx, uri, opts).await
}

#[cfg(feature = "http")]
pub async fn put(
	ctx: &Context,
	(uri, body, opts): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	let uri = try_as_uri("http::put", uri)?;
	let opts = try_as_opts("http::put", "The third argument should be an object.", opts)?;
	crate::fnc::util::http::put(ctx, uri, body.unwrap_or(Value::Null), opts).await
}

#[cfg(feature = "http")]
pub async fn post(
	ctx: &Context,
	(uri, body, opts): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	let uri = try_as_uri("http::post", uri)?;
	let opts = try_as_opts("http::post", "The third argument should be an object.", opts)?;
	crate::fnc::util::http::post(ctx, uri, body.unwrap_or(Value::Null), opts).await
}

#[cfg(feature = "http")]
pub async fn patch(
	ctx: &Context,
	(uri, body, opts): (Value, Option<Value>, Option<Value>),
) -> Result<Value, Error> {
	let uri = try_as_uri("http::patch", uri)?;
	let opts = try_as_opts("http::patch", "The third argument should be an object.", opts)?;
	crate::fnc::util::http::patch(ctx, uri, body.unwrap_or(Value::Null), opts).await
}

#[cfg(feature = "http")]
pub async fn delete(ctx: &Context, (uri, opts): (Value, Option<Value>)) -> Result<Value, Error> {
	let uri = try_as_uri("http::delete", uri)?;
	let opts = try_as_opts("http::delete", "The second argument should be an object.", opts)?;
	crate::fnc::util::http::delete(ctx, uri, opts).await
}
use crate::err::Error;
use crate::fnc::util::math::bottom::Bottom;
use crate::fnc::util::math::deviation::Deviation;
use crate::fnc::util::math::interquartile::Interquartile;
use crate::fnc::util::math::mean::Mean;
use crate::fnc::util::math::median::Median;
use crate::fnc::util::math::midhinge::Midhinge;
use crate::fnc::util::math::mode::Mode;
use crate::fnc::util::math::nearestrank::Nearestrank;
use crate::fnc::util::math::percentile::Percentile;
use crate::fnc::util::math::spread::Spread;
use crate::fnc::util::math::top::Top;
use crate::fnc::util::math::trimean::Trimean;
use crate::fnc::util::math::variance::Variance;
use crate::sql::number::{Number, Sort};
use crate::sql::value::{TryPow, Value};

pub fn abs((arg,): (Number,)) -> Result<Value, Error> {
	let Some(x) = arg.checked_abs() else {
		return Err(Error::ArithmeticOverflow(format!("math::abs({arg})")));
	};
	Ok(x.into())
}

pub fn acos((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.acos().into())
}

pub fn acot((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.acot().into())
}

pub fn asin((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.asin().into())
}

pub fn atan((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.atan().into())
}

pub fn bottom((array, c): (Vec<Number>, i64)) -> Result<Value, Error> {
	if c > 0 {
		Ok(array.bottom(c).into())
	} else {
		Err(Error::InvalidArguments {
			name: String::from("math::bottom"),
			message: String::from("The second argument must be an integer greater than 0."),
		})
	}
}

pub fn ceil((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.ceil().into())
}

pub fn clamp((arg, min, max): (Number, Number, Number)) -> Result<Value, Error> {
	if min > max {
		return Err(Error::InvalidArguments {
			name: "math::clamp".to_string(),
			message: "Lowerbound for clamp must be smaller the the upperbound".to_string(),
		});
	}
	Ok(arg.clamp(min, max).into())
}

pub fn cos((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.cos().into())
}
pub fn cot((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.cot().into())
}

pub fn deg2rad((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.deg2rad().into())
}

pub fn fixed((arg, p): (Number, i64)) -> Result<Value, Error> {
	if p > 0 {
		Ok(arg.fixed(p as usize).into())
	} else {
		Err(Error::InvalidArguments {
			name: String::from("math::fixed"),
			message: String::from("The second argument must be an integer greater than 0."),
		})
	}
}

pub fn floor((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.floor().into())
}

pub fn interquartile((mut array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.sorted().interquartile().into())
}

pub fn lerp((from, to, factor): (Number, Number, Number)) -> Result<Value, Error> {
	Ok(factor.lerp(from, to).into())
}

pub fn lerpangle((from, to, factor): (Number, Number, Number)) -> Result<Value, Error> {
	Ok(factor.lerp_angle(from, to).into())
}

pub fn ln((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.ln().into())
}

pub fn log((arg, base): (Number, Number)) -> Result<Value, Error> {
	Ok(arg.log(base).into())
}

pub fn log10((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.log10().into())
}

pub fn log2((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.log2().into())
}

pub fn max((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(match array.into_iter().max() {
		Some(v) => v.into(),
		None => Value::None,
	})
}

pub fn mean((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.mean().into())
}

pub fn median((mut array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(match array.is_empty() {
		true => Value::None,
		false => array.sorted().median().into(),
	})
}

pub fn midhinge((mut array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.sorted().midhinge().into())
}

pub fn min((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(match array.into_iter().min() {
		Some(v) => v.into(),
		None => Value::None,
	})
}

pub fn mode((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.mode().into())
}

pub fn nearestrank((mut array, n): (Vec<Number>, Number)) -> Result<Value, Error> {
	Ok(array.sorted().nearestrank(n).into())
}

pub fn percentile((mut array, n): (Vec<Number>, Number)) -> Result<Value, Error> {
	Ok(array.sorted().percentile(n).into())
}

pub fn pow((arg, pow): (Number, Number)) -> Result<Value, Error> {
	Ok(arg.try_pow(pow)?.into())
}

pub fn product((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.into_iter().product::<Number>().into())
}

pub fn rad2deg((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.rad2deg().into())
}

pub fn round((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.round().into())
}

pub fn sign((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.sign().into())
}

pub fn sin((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.sin().into())
}

pub fn spread((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.spread().into())
}

pub fn sqrt((arg,): (Number,)) -> Result<Value, Error> {
	Ok(match arg {
		v if v >= Number::Int(0) => v.sqrt().into(),
		_ => Value::None,
	})
}

pub fn stddev((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.deviation(true).into())
}

pub fn sum((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.into_iter().sum::<Number>().into())
}
pub fn tan((arg,): (Number,)) -> Result<Value, Error> {
	Ok(arg.tan().into())
}

pub fn top((array, c): (Vec<Number>, i64)) -> Result<Value, Error> {
	if c > 0 {
		Ok(array.top(c).into())
	} else {
		Err(Error::InvalidArguments {
			name: String::from("math::top"),
			message: String::from("The second argument must be an integer greater than 0."),
		})
	}
}

pub fn trimean((mut array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.sorted().trimean().into())
}

pub fn variance((array,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(array.variance(true).into())
}
//! Executes functions from SQL. If there is an SQL function it will be defined in this module.

use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::idx::planner::executor::QueryExecutor;
use crate::sql::value::Value;
use crate::sql::Thing;
use reblessive::tree::Stk;
pub mod api;
pub mod args;
pub mod array;
pub mod bytes;
pub mod count;
pub mod crypto;
pub mod duration;
pub mod encoding;
pub mod file;
pub mod geo;
pub mod http;
pub mod math;
pub mod not;
pub mod object;
pub mod operate;
pub mod parse;
pub mod rand;
pub mod record;
pub mod script;
pub mod search;
pub mod session;
pub mod sleep;
pub mod string;
pub mod time;
pub mod r#type;
pub mod util;
pub mod value;
pub mod vector;

/// Attempts to run any function
pub async fn run(
	stk: &mut Stk,
	ctx: &Context,
	opt: &Options,
	doc: Option<&CursorDoc>,
	name: &str,
	args: Vec<Value>,
) -> Result<Value, Error> {
	if name.eq("sleep")
		|| name.eq("api::invoke")
		|| name.eq("array::all")
		|| name.eq("array::any")
		|| name.eq("array::every")
		|| name.eq("array::filter_index")
		|| name.eq("array::filter")
		|| name.eq("array::find_index")
		|| name.eq("array::find")
		|| name.eq("array::fold")
		|| name.eq("array::includes")
		|| name.eq("array::index_of")
		|| name.eq("array::map")
		|| name.eq("array::reduce")
		|| name.eq("array::some")
		|| name.eq("record::exists")
		|| name.eq("record::refs")
		|| name.eq("type::field")
		|| name.eq("type::fields")
		|| name.eq("value::diff")
		|| name.eq("value::patch")
		|| name.starts_with("file")
		|| name.starts_with("http")
		|| name.starts_with("search")
		|| name.starts_with("crypto::argon2")
		|| name.starts_with("crypto::bcrypt")
		|| name.starts_with("crypto::pbkdf2")
		|| name.starts_with("crypto::scrypt")
	{
		stk.run(|stk| asynchronous(stk, ctx, opt, doc, name, args)).await
	} else {
		synchronous(ctx, doc, name, args)
	}
}

/// Each function is specified by its name (a string literal) followed by its path. The path
/// may be followed by one parenthesized argument, e.g. ctx, which is passed to the function
/// before the remainder of the arguments. The path may be followed by `.await` to signify that
/// it is `async`. Finally, the path may be prefixed by a parenthesized wrapper function e.g.
/// `cpu_intensive`.
macro_rules! dispatch {
	($name: ident, $args: expr, $message: expr, $($function_name: literal => $(($wrapper: tt))* $($function_path: ident)::+ $(($ctx_arg: expr))* $(.$await:tt)*,)+) => {
		{
			match $name {
				$($function_name => {
					let args = args::FromArgs::from_args($name, $args)?;
					#[allow(clippy::redundant_closure_call)]
					$($wrapper)*(|| $($function_path)::+($($ctx_arg,)* args))()$(.$await)*
				},)+
				_ => {
					Err($crate::err::Error::InvalidFunction{
						name: String::from($name),
						message: $message.to_string()
					})
				}
			}
		}
	};
}

/// Attempts to run any synchronous function.
pub fn synchronous(
	ctx: &Context,
	doc: Option<&CursorDoc>,
	name: &str,
	args: Vec<Value>,
) -> Result<Value, Error> {
	dispatch!(
		name,
		args,
		"no such builtin function found",
		//
		"array::add" => array::add,
		"array::append" => array::append,
		"array::at" => array::at,
		"array::boolean_and" => array::boolean_and,
		"array::boolean_not" => array::boolean_not,
		"array::boolean_or" => array::boolean_or,
		"array::boolean_xor" => array::boolean_xor,
		"array::clump" => array::clump,
		"array::combine" => array::combine,
		"array::complement" => array::complement,
		"array::concat" => array::concat,
		"array::difference" => array::difference,
		"array::distinct" => array::distinct,
		"array::fill" => array::fill,
		"array::first" => array::first,
		"array::flatten" => array::flatten,
		"array::group" => array::group,
		"array::insert" => array::insert,
		"array::intersect" => array::intersect,
		"array::is_empty" => array::is_empty,
		"array::join" => array::join,
		"array::last" => array::last,
		"array::len" => array::len,
		"array::logical_and" => array::logical_and,
		"array::logical_or" => array::logical_or,
		"array::logical_xor" => array::logical_xor,
		"array::matches" => array::matches,
		"array::max" => array::max,
		"array::min" => array::min,
		"array::pop" => array::pop,
		"array::prepend" => array::prepend,
		"array::push" => array::push,
		"array::range" => array::range,
		"array::remove" => array::remove,
		"array::repeat" => array::repeat,
		"array::reverse" => array::reverse,
		"array::shuffle" => array::shuffle,
		"array::slice" => array::slice,
		"array::sort" => array::sort,
		"array::sort_natural" => array::sort_natural,
		"array::sort_lexical" => array::sort_lexical,
		"array::sort_natural_lexical" => array::sort_natural_lexical,
		"array::swap" => array::swap,
		"array::transpose" => array::transpose,
		"array::union" => array::union,
		"array::sort::asc" => array::sort::asc,
		"array::sort::desc" => array::sort::desc,
		"array::windows" => array::windows,
		//
		"bytes::len" => bytes::len,
		//
		"count" => count::count,
		//
		"crypto::blake3" => crypto::blake3,
		"crypto::md5" => crypto::md5,
		"crypto::sha1" => crypto::sha1,
		"crypto::sha256" => crypto::sha256,
		"crypto::sha512" => crypto::sha512,
		//
		"duration::days" => duration::days,
		"duration::hours" => duration::hours,
		"duration::micros" => duration::micros,
		"duration::millis" => duration::millis,
		"duration::mins" => duration::mins,
		"duration::nanos" => duration::nanos,
		"duration::secs" => duration::secs,
		"duration::weeks" => duration::weeks,
		"duration::years" => duration::years,
		"duration::from::days" => duration::from::days,
		"duration::from::hours" => duration::from::hours,
		"duration::from::micros" => duration::from::micros,
		"duration::from::millis" => duration::from::millis,
		"duration::from::mins" => duration::from::mins,
		"duration::from::nanos" => duration::from::nanos,
		"duration::from::secs" => duration::from::secs,
		"duration::from::weeks" => duration::from::weeks,
		//
		"encoding::base64::decode" => encoding::base64::decode,
		"encoding::base64::encode" => encoding::base64::encode,
		//
		"geo::area" => geo::area,
		"geo::bearing" => geo::bearing,
		"geo::centroid" => geo::centroid,
		"geo::distance" => geo::distance,
		"geo::hash::decode" => geo::hash::decode,
		"geo::hash::encode" => geo::hash::encode,
		"geo::is::valid" => geo::is::valid,
		//
		"math::abs" => math::abs,
		"math::acos" => math::acos,
		"math::acot" => math::acot,
		"math::asin" => math::asin,
		"math::atan" => math::atan,
		"math::bottom" => math::bottom,
		"math::ceil" => math::ceil,
		"math::clamp" => math::clamp,
		"math::cos" => math::cos,
		"math::cot" => math::cot,
		"math::deg2rad" => math::deg2rad,
		"math::fixed" => math::fixed,
		"math::floor" => math::floor,
		"math::interquartile" => math::interquartile,
		"math::lerp" => math::lerp,
		"math::lerpangle" => math::lerpangle,
		"math::ln" => math::ln,
		"math::log" => math::log,
		"math::log10" => math::log10,
		"math::log2" => math::log2,
		"math::max" => math::max,
		"math::mean" => math::mean,
		"math::median" => math::median,
		"math::midhinge" => math::midhinge,
		"math::min" => math::min,
		"math::mode" => math::mode,
		"math::nearestrank" => math::nearestrank,
		"math::percentile" => math::percentile,
		"math::pow" => math::pow,
		"math::product" => math::product,
		"math::rad2deg" => math::rad2deg,
		"math::round" => math::round,
		"math::sign" => math::sign,
		"math::sin" => math::sin,
		"math::spread" => math::spread,
		"math::sqrt" => math::sqrt,
		"math::stddev" => math::stddev,
		"math::sum" => math::sum,
		"math::tan" => math::tan,
		"math::top" => math::top,
		"math::trimean" => math::trimean,
		"math::variance" => math::variance,
		//
		"meta::id" => record::id,
		"meta::tb" => record::tb,
		//
		"not" => not::not,
		//
		"object::entries" => object::entries,
		"object::from_entries" => object::from_entries,
		"object::is_empty" => object::is_empty,
		"object::keys" => object::keys,
		"object::len" => object::len,
		"object::values" => object::values,
		//
		"parse::email::host" => parse::email::host,
		"parse::email::user" => parse::email::user,
		"parse::url::domain" => parse::url::domain,
		"parse::url::fragment" => parse::url::fragment,
		"parse::url::host" => parse::url::host,
		"parse::url::path" => parse::url::path,
		"parse::url::port" => parse::url::port,
		"parse::url::query" => parse::url::query,
		"parse::url::scheme" => parse::url::scheme,
		//
		"rand" => rand::rand,
		"rand::bool" => rand::bool,
		"rand::enum" => rand::r#enum,
		"rand::float" => rand::float,
		"rand::guid" => rand::guid,
		"rand::int" => rand::int,
		"rand::string" => rand::string,
		"rand::time" => rand::time,
		"rand::ulid" => rand::ulid,
		"rand::uuid::v4" => rand::uuid::v4,
		"rand::uuid::v7" => rand::uuid::v7,
		"rand::uuid" => rand::uuid,
		//
		"record::id" => record::id,
		"record::table" => record::tb,
		"record::tb" => record::tb,
		//
		"session::ac" => session::ac(ctx),
		"session::db" => session::db(ctx),
		"session::id" => session::id(ctx),
		"session::ip" => session::ip(ctx),
		"session::ns" => session::ns(ctx),
		"session::origin" => session::origin(ctx),
		"session::rd" => session::rd(ctx),
		"session::token" => session::token(ctx),
		//
		"string::concat" => string::concat,
		"string::contains" => string::contains,
		"string::ends_with" => string::ends_with,
		"string::join" => string::join,
		"string::len" => string::len,
		"string::lowercase" => string::lowercase,
		"string::matches" => string::matches,
		"string::repeat" => string::repeat,
		"string::replace" => string::replace,
		"string::reverse" => string::reverse,
		"string::slice" => string::slice,
		"string::slug" => string::slug,
		"string::split" => string::split,
		"string::starts_with" => string::starts_with,
		"string::trim" => string::trim,
		"string::uppercase" => string::uppercase,
		"string::words" => string::words,
		//
		"string::distance::damerau_levenshtein" => string::distance::damerau_levenshtein,
		"string::distance::hamming" => string::distance::hamming,
		"string::distance::levenshtein" => string::distance::levenshtein,
		"string::distance::normalized_damerau_levenshtein" => string::distance::normalized_damerau_levenshtein,
		"string::distance::normalized_levenshtein" => string::distance::normalized_levenshtein,
		"string::distance::osa_distance" => string::distance::osa_distance,
		//
		"string::html::encode" => string::html::encode,
		"string::html::sanitize" => string::html::sanitize,
		"string::is::alphanum" => string::is::alphanum,
		"string::is::alpha" => string::is::alpha,
		"string::is::ascii" => string::is::ascii,
		"string::is::datetime" => string::is::datetime,
		"string::is::domain" => string::is::domain,
		"string::is::email" => string::is::email,
		"string::is::hexadecimal" => string::is::hexadecimal,
		"string::is::ip" => string::is::ip,
		"string::is::ipv4" => string::is::ipv4,
		"string::is::ipv6" => string::is::ipv6,
		"string::is::latitude" => string::is::latitude,
		"string::is::longitude" => string::is::longitude,
		"string::is::numeric" => string::is::numeric,
		"string::is::semver" => string::is::semver,
		"string::is::url" => string::is::url,
		"string::is::ulid" => string::is::ulid,
		"string::is::uuid" => string::is::uuid,
		"string::is::record" => string::is::record,
		//
		"string::similarity::fuzzy" => string::similarity::fuzzy,
		"string::similarity::jaro" => string::similarity::jaro,
		"string::similarity::jaro_winkler" => string::similarity::jaro_winkler,
		"string::similarity::smithwaterman" => string::similarity::smithwaterman,
		"string::similarity::sorensen_dice" => string::similarity::sorensen_dice,
		//
		"string::semver::compare" => string::semver::compare,
		"string::semver::major" => string::semver::major,
		"string::semver::minor" => string::semver::minor,
		"string::semver::patch" => string::semver::patch,
		"string::semver::inc::major" => string::semver::inc::major,
		"string::semver::inc::minor" => string::semver::inc::minor,
		"string::semver::inc::patch" => string::semver::inc::patch,
		"string::semver::set::major" => string::semver::set::major,
		"string::semver::set::minor" => string::semver::set::minor,
		"string::semver::set::patch" => string::semver::set::patch,
		//
		"time::ceil" => time::ceil,
		"time::day" => time::day,
		"time::floor" => time::floor,
		"time::format" => time::format,
		"time::group" => time::group,
		"time::hour" => time::hour,
		"time::max" => time::max,
		"time::min" => time::min,
		"time::minute" => time::minute,
		"time::month" => time::month,
		"time::nano" => time::nano,
		"time::micros" => time::micros,
		"time::millis" => time::millis,
		"time::now" => time::now,
		"time::round" => time::round,
		"time::second" => time::second,
		"time::timezone" => time::timezone,
		"time::unix" => time::unix,
		"time::wday" => time::wday,
		"time::week" => time::week,
		"time::yday" => time::yday,
		"time::year" => time::year,
		"time::from::nanos" => time::from::nanos,
		"time::from::micros" => time::from::micros,
		"time::from::millis" => time::from::millis,
		"time::from::secs" => time::from::secs,
		"time::from::ulid" => time::from::ulid,
		"time::from::unix" => time::from::unix,
		"time::from::uuid" => time::from::uuid,
		"time::is::leap_year" => time::is::leap_year,
		//
		"type::array" => r#type::array,
		"type::bool" => r#type::bool,
		"type::bytes" => r#type::bytes,
		"type::datetime" => r#type::datetime,
		"type::decimal" => r#type::decimal,
		"type::duration" => r#type::duration,
		"type::file" => r#type::file,
		"type::float" => r#type::float,
		"type::geometry" => r#type::geometry,
		"type::int" => r#type::int,
		"type::number" => r#type::number,
		"type::point" => r#type::point,
		"type::range" => r#type::range,
		"type::record" => r#type::record,
		"type::string" => r#type::string,
		"type::string_lossy" => r#type::string_lossy,
		"type::table" => r#type::table,
		"type::thing" => r#type::thing,
		"type::uuid" => r#type::uuid,
		"type::is::array" => r#type::is::array,
		"type::is::bool" => r#type::is::bool,
		"type::is::bytes" => r#type::is::bytes,
		"type::is::collection" => r#type::is::collection,
		"type::is::datetime" => r#type::is::datetime,
		"type::is::decimal" => r#type::is::decimal,
		"type::is::duration" => r#type::is::duration,
		"type::is::float" => r#type::is::float,
		"type::is::geometry" => r#type::is::geometry,
		"type::is::int" => r#type::is::int,
		"type::is::line" => r#type::is::line,
		"type::is::none" => r#type::is::none,
		"type::is::null" => r#type::is::null,
		"type::is::multiline" => r#type::is::multiline,
		"type::is::multipoint" => r#type::is::multipoint,
		"type::is::multipolygon" => r#type::is::multipolygon,
		"type::is::number" => r#type::is::number,
		"type::is::object" => r#type::is::object,
		"type::is::point" => r#type::is::point,
		"type::is::polygon" => r#type::is::polygon,
		"type::is::range" => r#type::is::range,
		"type::is::record" => r#type::is::record,
		"type::is::string" => r#type::is::string,
		"type::is::uuid" => r#type::is::uuid,
		//
		"vector::add" => vector::add,
		"vector::angle" => vector::angle,
		"vector::cross" => vector::cross,
		"vector::dot" => vector::dot,
		"vector::divide" => vector::divide,
		"vector::magnitude" => vector::magnitude,
		"vector::multiply" => vector::multiply,
		"vector::normalize" => vector::normalize,
		"vector::project" => vector::project,
		"vector::scale" => vector::scale,
		"vector::subtract" => vector::subtract,
		"vector::distance::chebyshev" => vector::distance::chebyshev,
		"vector::distance::euclidean" => vector::distance::euclidean,
		"vector::distance::hamming" => vector::distance::hamming,
		"vector::distance::knn" => vector::distance::knn((ctx, doc)),
		"vector::distance::mahalanobis" => vector::distance::mahalanobis,
		"vector::distance::manhattan" => vector::distance::manhattan,
		"vector::distance::minkowski" => vector::distance::minkowski,
		"vector::similarity::cosine" => vector::similarity::cosine,
		"vector::similarity::jaccard" => vector::similarity::jaccard,
		"vector::similarity::pearson" => vector::similarity::pearson,
		"vector::similarity::spearman" => vector::similarity::spearman,
	)
}

/// Attempts to run any asynchronous function.
pub async fn asynchronous(
	stk: &mut Stk,
	ctx: &Context,
	opt: &Options,
	doc: Option<&CursorDoc>,
	name: &str,
	args: Vec<Value>,
) -> Result<Value, Error> {
	// Wrappers return a function as opposed to a value so that the dispatch! method can always
	// perform a function call.
	#[cfg(not(target_family = "wasm"))]
	fn cpu_intensive<R: Send + 'static>(
		function: impl FnOnce() -> R + Send + 'static,
	) -> impl FnOnce() -> std::pin::Pin<Box<dyn std::future::Future<Output = R> + Send>> {
		|| Box::pin(crate::exe::spawn(function))
	}

	#[cfg(target_family = "wasm")]
	fn cpu_intensive<R: Send + 'static>(
		function: impl FnOnce() -> R + Send + 'static,
	) -> impl FnOnce() -> std::future::Ready<R> {
		|| std::future::ready(function())
	}

	dispatch!(
		name,
		args,
		"no such builtin function found",
		//
		"api::invoke" => api::invoke((stk, ctx, opt)).await,
		//
		"array::all" => array::all((stk, ctx, Some(opt), doc)).await,
		"array::any" => array::any((stk, ctx, Some(opt), doc)).await,
		"array::every" => array::all((stk, ctx, Some(opt), doc)).await,
		"array::filter" => array::filter((stk, ctx, Some(opt), doc)).await,
		"array::filter_index" => array::filter_index((stk, ctx, Some(opt), doc)).await,
		"array::find" => array::find((stk, ctx, Some(opt), doc)).await,
		"array::find_index" => array::find_index((stk, ctx, Some(opt), doc)).await,
		"array::fold" => array::fold((stk, ctx, Some(opt), doc)).await,
		"array::includes" => array::any((stk, ctx, Some(opt), doc)).await,
		"array::index_of" => array::find_index((stk, ctx, Some(opt), doc)).await,
		"array::map" => array::map((stk, ctx, Some(opt), doc)).await,
		"array::reduce" => array::reduce((stk, ctx, Some(opt), doc)).await,
		"array::some" => array::any((stk, ctx, Some(opt), doc)).await,
		//
		"crypto::argon2::compare" => (cpu_intensive) crypto::argon2::cmp.await,
		"crypto::argon2::generate" => (cpu_intensive) crypto::argon2::gen.await,
		"crypto::bcrypt::compare" => (cpu_intensive) crypto::bcrypt::cmp.await,
		"crypto::bcrypt::generate" => (cpu_intensive) crypto::bcrypt::gen.await,
		"crypto::pbkdf2::compare" => (cpu_intensive) crypto::pbkdf2::cmp.await,
		"crypto::pbkdf2::generate" => (cpu_intensive) crypto::pbkdf2::gen.await,
		"crypto::scrypt::compare" => (cpu_intensive) crypto::scrypt::cmp.await,
		"crypto::scrypt::generate" => (cpu_intensive) crypto::scrypt::gen.await,
		//
		"file::put" => file::put((stk, ctx, opt, doc)).await,
		"file::get" => file::get((stk, ctx, opt, doc)).await,
		"file::head" => file::head((stk, ctx, opt, doc)).await,
		"file::delete" => file::delete((stk, ctx, opt, doc)).await,
		"file::copy" => file::copy((stk, ctx, opt, doc)).await,
		"file::copy_if_not_exists" => file::copy_if_not_exists((stk, ctx, opt, doc)).await,
		"file::rename" => file::rename((stk, ctx, opt, doc)).await,
		"file::rename_if_not_exists" => file::rename_if_not_exists((stk, ctx, opt, doc)).await,
		"file::exists" => file::exists((stk, ctx, opt, doc)).await,
		//
		"http::head" => http::head(ctx).await,
		"http::get" => http::get(ctx).await,
		"http::put" => http::put(ctx).await,
		"http::post" =>  http::post(ctx).await,
		"http::patch" => http::patch(ctx).await,
		"http::delete" => http::delete(ctx).await,
		//
		"record::exists" => record::exists((stk, ctx, Some(opt), doc)).await,
		"record::refs" => record::refs((stk, ctx, opt, doc)).await,
		//
		"search::analyze" => search::analyze((stk, ctx, Some(opt))).await,
		"search::score" => search::score((ctx, doc)).await,
		"search::highlight" => search::highlight((ctx, doc)).await,
		"search::offsets" => search::offsets((ctx, doc)).await,
		//
		"sleep" => sleep::sleep(ctx).await,
		//
		"type::field" => r#type::field((stk, ctx, Some(opt), doc)).await,
		"type::fields" => r#type::fields((stk, ctx, Some(opt), doc)).await,
		//
		"value::diff" => value::diff((stk, ctx, Some(opt), doc)).await,
		"value::patch" => value::patch((stk, ctx, Some(opt), doc)).await,
	)
}

/// Attempts to run any synchronous function.
pub async fn idiom(
	stk: &mut Stk,
	ctx: &Context,
	opt: &Options,
	doc: Option<&CursorDoc>,
	value: Value,
	name: &str,
	args: Vec<Value>,
) -> Result<Value, Error> {
	let args = [vec![value.clone()], args].concat();
	let specific = match value {
		Value::Array(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the array type",
				//
				"add" => array::add,
				"all" => array::all((stk, ctx, Some(opt), doc)).await,
				"any" => array::any((stk, ctx, Some(opt), doc)).await,
				"append" => array::append,
				"at" => array::at,
				"boolean_and" => array::boolean_and,
				"boolean_not" => array::boolean_not,
				"boolean_or" => array::boolean_or,
				"boolean_xor" => array::boolean_xor,
				"clump" => array::clump,
				"combine" => array::combine,
				"complement" => array::complement,
				"concat" => array::concat,
				"difference" => array::difference,
				"distinct" => array::distinct,
				"every" => array::all((stk, ctx, Some(opt), doc)).await,
				"fill" => array::fill,
				"filter" => array::filter((stk, ctx, Some(opt), doc)).await,
				"filter_index" => array::filter_index((stk, ctx, Some(opt), doc)).await,
				"find" => array::find((stk, ctx, Some(opt), doc)).await,
				"find_index" => array::find_index((stk, ctx, Some(opt), doc)).await,
				"first" => array::first,
				"fold" => array::fold((stk, ctx, Some(opt), doc)).await,
				"flatten" => array::flatten,
				"group" => array::group,
				"includes" => array::any((stk, ctx, Some(opt), doc)).await,
				"index_of" => array::find_index((stk, ctx, Some(opt), doc)).await,
				"insert" => array::insert,
				"intersect" => array::intersect,
				"is_empty" => array::is_empty,
				"join" => array::join,
				"last" => array::last,
				"len" => array::len,
				"logical_and" => array::logical_and,
				"logical_or" => array::logical_or,
				"logical_xor" => array::logical_xor,
				"matches" => array::matches,
				"map" => array::map((stk, ctx, Some(opt), doc)).await,
				"max" => array::max,
				"min" => array::min,
				"pop" => array::pop,
				"prepend" => array::prepend,
				"push" => array::push,
				"reduce" => array::reduce((stk, ctx, Some(opt), doc)).await,
				"remove" => array::remove,
				"reverse" => array::reverse,
				"shuffle" => array::shuffle,
				"slice" => array::slice,
				"some" => array::any((stk, ctx, Some(opt), doc)).await,
				"sort" => array::sort,
				"sort_natural" => array::sort_natural,
				"sort_lexical" => array::sort_lexical,
				"sort_natural_lexical" => array::sort_natural_lexical,
				"swap" => array::swap,
				"transpose" => array::transpose,
				"union" => array::union,
				"sort_asc" => array::sort::asc,
				"sort_desc" => array::sort::desc,
				"windows" => array::windows,
				//
				"vector_add" => vector::add,
				"vector_angle" => vector::angle,
				"vector_cross" => vector::cross,
				"vector_dot" => vector::dot,
				"vector_divide" => vector::divide,
				"vector_magnitude" => vector::magnitude,
				"vector_multiply" => vector::multiply,
				"vector_normalize" => vector::normalize,
				"vector_project" => vector::project,
				"vector_scale" => vector::scale,
				"vector_subtract" => vector::subtract,
				"vector_distance_chebyshev" => vector::distance::chebyshev,
				"vector_distance_euclidean" => vector::distance::euclidean,
				"vector_distance_hamming" => vector::distance::hamming,
				"vector_distance_knn" => vector::distance::knn((ctx, doc)),
				"vector_distance_mahalanobis" => vector::distance::mahalanobis,
				"vector_distance_manhattan" => vector::distance::manhattan,
				"vector_distance_minkowski" => vector::distance::minkowski,
				"vector_similarity_cosine" => vector::similarity::cosine,
				"vector_similarity_jaccard" => vector::similarity::jaccard,
				"vector_similarity_pearson" => vector::similarity::pearson,
				"vector_similarity_spearman" => vector::similarity::spearman,
			)
		}
		Value::Bytes(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the bytes type",
				//
				"len" => bytes::len,
			)
		}
		Value::Duration(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the duration type",
				//
				"days" => duration::days,
				"hours" => duration::hours,
				"micros" => duration::micros,
				"millis" => duration::millis,
				"mins" => duration::mins,
				"nanos" => duration::nanos,
				"secs" => duration::secs,
				"weeks" => duration::weeks,
				"years" => duration::years,
			)
		}
		Value::Geometry(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the geometry type",
				//
				"area" => geo::area,
				"bearing" => geo::bearing,
				"centroid" => geo::centroid,
				"distance" => geo::distance,
				"hash_decode" => geo::hash::decode,
				"hash_encode" => geo::hash::encode,
				"is_valid" => geo::is::valid,
			)
		}
		Value::Thing(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the record type",
				//
				"exists" => record::exists((stk, ctx, Some(opt), doc)).await,
				"id" => record::id,
				"table" => record::tb,
				"tb" => record::tb,
				"refs" => record::refs((stk, ctx, opt, doc)).await,
			)
		}
		Value::Object(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the object type",
				//
				"entries" => object::entries,
				"is_empty" => object::is_empty,
				"keys" => object::keys,
				"len" => object::len,
				"values" => object::values,
			)
		}
		Value::Number(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the number type",
				//
				"abs" => math::abs,
				"acos" => math::acos,
				"acot" => math::acot,
				"asin" => math::asin,
				"atan" => math::atan,
				"ceil" => math::ceil,
				"cos" => math::cos,
				"cot" => math::cot,
				"deg2rad" => math::deg2rad,
				"floor" => math::floor,
				"ln" => math::ln,
				"log" => math::log,
				"log10" => math::log10,
				"log2" => math::log2,
				"rad2deg" => math::rad2deg,
				"round" => math::round,
				"sign" => math::sign,
				"sin" => math::sin,
				"tan" => math::tan,
			)
		}
		Value::Strand(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the string type",
				//
				"concat" => string::concat,
				"contains" => string::contains,
				"ends_with" => string::ends_with,
				"join" => string::join,
				"len" => string::len,
				"lowercase" => string::lowercase,
				"matches" => string::matches,
				"repeat" => string::repeat,
				"replace" => string::replace,
				"reverse" => string::reverse,
				"slice" => string::slice,
				"slug" => string::slug,
				"split" => string::split,
				"starts_with" => string::starts_with,
				"trim" => string::trim,
				"uppercase" => string::uppercase,
				"words" => string::words,
				"distance_damerau_levenshtein" => string::distance::damerau_levenshtein,
				"distance_hamming" => string::distance::hamming,
				"distance_levenshtein" => string::distance::levenshtein,
				"distance_normalized_damerau_levenshtein" => string::distance::normalized_damerau_levenshtein,
				"distance_normalized_levenshtein" => string::distance::normalized_levenshtein,
				"html_encode" => string::html::encode,
				"html_sanitize" => string::html::sanitize,
				"is_alphanum" => string::is::alphanum,
				"is_alpha" => string::is::alpha,
				"is_ascii" => string::is::ascii,
				"is_datetime" => string::is::datetime,
				"is_domain" => string::is::domain,
				"is_email" => string::is::email,
				"is_hexadecimal" => string::is::hexadecimal,
				"is_ip" => string::is::ip,
				"is_ipv4" => string::is::ipv4,
				"is_ipv6" => string::is::ipv6,
				"is_latitude" => string::is::latitude,
				"is_longitude" => string::is::longitude,
				"is_numeric" => string::is::numeric,
				"is_semver" => string::is::semver,
				"is_url" => string::is::url,
				"is_ulid" => string::is::ulid,
				"is_uuid" => string::is::uuid,
				"is_record" => string::is::record,
				"similarity_fuzzy" => string::similarity::fuzzy,
				"similarity_jaro" => string::similarity::jaro,
				"similarity_jaro_winkler" => string::similarity::jaro_winkler,
				"similarity_smithwaterman" => string::similarity::smithwaterman,
				"similarity_sorensen_dice" => string::similarity::sorensen_dice,
				"semver_compare" => string::semver::compare,
				"semver_major" => string::semver::major,
				"semver_minor" => string::semver::minor,
				"semver_patch" => string::semver::patch,
				"semver_inc_major" => string::semver::inc::major,
				"semver_inc_minor" => string::semver::inc::minor,
				"semver_inc_patch" => string::semver::inc::patch,
				"semver_set_major" => string::semver::set::major,
				"semver_set_minor" => string::semver::set::minor,
				"semver_set_patch" => string::semver::set::patch,
			)
		}
		Value::Datetime(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the datetime type",
				//
				"ceil" => time::ceil,
				"day" => time::day,
				"floor" => time::floor,
				"format" => time::format,
				"group" => time::group,
				"hour" => time::hour,
				"is_leap_year" => time::is::leap_year,
				"micros" => time::micros,
				"millis" => time::millis,
				"minute" => time::minute,
				"month" => time::month,
				"nano" => time::nano,
				"round" => time::round,
				"second" => time::second,
				"unix" => time::unix,
				"wday" => time::wday,
				"week" => time::week,
				"yday" => time::yday,
				"year" => time::year,
			)
		}
		Value::File(_) => {
			dispatch!(
				name,
				args.clone(),
				"no such method found for the file type",
				//
				"put" => file::put((stk, ctx, opt, doc)).await,
				"get" => file::get((stk, ctx, opt, doc)).await,
				"head" => file::head((stk, ctx, opt, doc)).await,
				"delete" => file::delete((stk, ctx, opt, doc)).await,
				"copy" => file::copy((stk, ctx, opt, doc)).await,
				"copy_if_not_exists" => file::copy_if_not_exists((stk, ctx, opt, doc)).await,
				"rename" => file::rename((stk, ctx, opt, doc)).await,
				"rename_if_not_exists" => file::rename_if_not_exists((stk, ctx, opt, doc)).await,
				"exists" => file::exists((stk, ctx, opt, doc)).await,
			)
		}
		_ => Err(Error::InvalidFunction {
			name: "".into(),
			message: "".into(),
		}),
	};

	match specific {
		Err(Error::InvalidFunction {
			..
		}) => {
			let message = format!("no such method found for the {} type", value.kindof());
			dispatch!(
				name,
				args,
				message,
				//
				"is_array" => r#type::is::array,
				"is_bool" => r#type::is::bool,
				"is_bytes" => r#type::is::bytes,
				"is_collection" => r#type::is::collection,
				"is_datetime" => r#type::is::datetime,
				"is_decimal" => r#type::is::decimal,
				"is_duration" => r#type::is::duration,
				"is_float" => r#type::is::float,
				"is_geometry" => r#type::is::geometry,
				"is_int" => r#type::is::int,
				"is_line" => r#type::is::line,
				"is_none" => r#type::is::none,
				"is_null" => r#type::is::null,
				"is_multiline" => r#type::is::multiline,
				"is_multipoint" => r#type::is::multipoint,
				"is_multipolygon" => r#type::is::multipolygon,
				"is_number" => r#type::is::number,
				"is_object" => r#type::is::object,
				"is_point" => r#type::is::point,
				"is_polygon" => r#type::is::polygon,
				"is_range" => r#type::is::range,
				"is_record" => r#type::is::record,
				"is_string" => r#type::is::string,
				"is_uuid" => r#type::is::uuid,
				//
				"to_array" => r#type::array,
				"to_bool" => r#type::bool,
				"to_bytes" => r#type::bytes,
				"to_datetime" => r#type::datetime,
				"to_decimal" => r#type::decimal,
				"to_duration" => r#type::duration,
				"to_float" => r#type::float,
				"to_geometry" => r#type::geometry,
				"to_int" => r#type::int,
				"to_number" => r#type::number,
				"to_point" => r#type::point,
				"to_range" => r#type::range,
				"to_record" => r#type::record,
				"to_string" => r#type::string,
				"to_string_lossy" => r#type::string_lossy,
				"to_uuid" => r#type::uuid,
				//
				"chain" => value::chain((stk, ctx, Some(opt), doc)).await,
				"diff" => value::diff((stk, ctx, Some(opt), doc)).await,
				"patch" => value::patch((stk, ctx, Some(opt), doc)).await,
				//
				"repeat" => array::repeat,
			)
		}
		v => v,
	}
}

fn get_execution_context<'a>(
	ctx: &'a Context,
	doc: Option<&'a CursorDoc>,
) -> Option<(&'a QueryExecutor, &'a CursorDoc, &'a Thing)> {
	if let Some(doc) = doc {
		if let Some(thg) = &doc.rid {
			if let Some(pla) = ctx.get_query_planner() {
				if let Some(exe) = pla.get_query_executor(&thg.tb) {
					return Some((exe, doc, thg));
				}
			}
		}
	}
	None
}

#[cfg(test)]
mod tests {
	use regex::Regex;

	use crate::dbs::Capabilities;
	use crate::{
		dbs::capabilities::ExperimentalTarget,
		sql::{statements::OutputStatement, Function, Query, Statement, Value},
	};

	#[tokio::test]
	async fn implementations_are_present() {
		// Accumulate and display all problems at once to avoid a test -> fix -> test -> fix cycle.
		let mut problems = Vec::new();

		// Read the source code of this file
		let fnc_mod = include_str!("mod.rs");

		// Patch out idiom methods
		let re = Regex::new(r"(?ms)pub async fn idiom\(.*}").unwrap();
		let fnc_no_idiom = re.replace(fnc_mod, "");

		for line in fnc_no_idiom.lines() {
			if !(line.contains("=>")
				&& (line.trim().starts_with('"') || line.trim().ends_with(',')))
			{
				// This line does not define a function name.
				continue;
			}

			let (quote, _) = line.split_once("=>").unwrap();
			let name = quote.trim().trim_matches('"');

			let res = crate::syn::parse_with_capabilities(
				&format!("RETURN {}()", name),
				&Capabilities::all().with_experimental(ExperimentalTarget::DefineApi.into()),
			);

			if let Ok(Query(mut x)) = res {
				match x.0.pop() {
					Some(Statement::Output(OutputStatement {
						what: Value::Function(x),
						..
					})) => match *x {
						Function::Normal(parsed_name, _) => {
							if parsed_name != name {
								problems
									.push(format!("function `{name}` parsed as `{parsed_name}`"));
							}
						}
						_ => {
							problems.push(format!("couldn't parse {name} function"));
						}
					},
					_ => {
						problems.push(format!("couldn't parse {name} function"));
					}
				}
			} else {
				problems.push(format!("couldn't parse {name} function"));
			}

			#[cfg(all(feature = "scripting", feature = "kv-mem"))]
			{
				use crate::sql::Value;

				let name = name.replace("::", ".");
				let sql =
					format!("RETURN function() {{ return typeof surrealdb.functions.{name}; }}");
				let dbs = crate::kvs::Datastore::new("memory")
					.await
					.unwrap()
					.with_capabilities(Capabilities::all());
				let ses = crate::dbs::Session::owner().with_ns("test").with_db("test");
				let res = &mut dbs.execute(&sql, &ses, None).await.unwrap();
				let tmp = res.remove(0).result.unwrap();
				if tmp == Value::from("object") {
					// Assume this function is superseded by a module of the same name.
				} else if tmp != Value::from("function") {
					problems.push(format!("function {name} not exported to JavaScript: {tmp:?}"));
				}
			}
		}

		if !problems.is_empty() {
			eprintln!("Functions not fully implemented:");
			for problem in problems {
				eprintln!(" - {problem}");
			}
			panic!("ensure functions can be parsed in core/src/sql/function.rs and are exported to JS in core/src/fnc/script/modules/surrealdb");
		}
	}
}
use crate::err::Error;
use crate::sql::Value;

/// Returns a boolean that is false if the input is truthy and true otherwise.
pub fn not((val,): (Value,)) -> Result<Value, Error> {
	Ok((!val.is_truthy()).into())
}
use crate::err::Error;
use crate::sql::value::Value;
use crate::sql::{Array, Object, Strand};
use std::collections::BTreeMap;

pub fn entries((object,): (Object,)) -> Result<Value, Error> {
	Ok(Value::Array(Array(
		object
			.iter()
			.map(|(k, v)| {
				Value::Array(Array(vec![Value::Strand(Strand(k.to_owned())), v.to_owned()]))
			})
			.collect(),
	)))
}

pub fn from_entries((array,): (Array,)) -> Result<Value, Error> {
	let mut obj: BTreeMap<String, Value> = BTreeMap::default();

	for v in array.iter() {
		match v {
			Value::Array(Array(entry)) if entry.len() == 2 => {
				let key = match entry.first() {
					Some(v) => match v {
						Value::Strand(v) => v.to_owned().to_raw(),
						v => v.to_string(),
					},
					_ => {
						return Err(Error::InvalidArguments {
							name: "object::from_entries".to_string(),
							message: "Expected entries, found invalid entry".to_string(),
						})
					}
				};

				let value = match entry.get(1) {
					Some(v) => v,
					_ => {
						return Err(Error::InvalidArguments {
							name: "object::from_entries".to_string(),
							message: "Expected entries, found invalid entry".to_string(),
						})
					}
				};

				obj.insert(key, value.to_owned());
			}
			_ => {
				return Err(Error::InvalidArguments {
					name: "object::from_entries".to_string(),
					message: format!("Expected entries, found {}", v.kindof()),
				})
			}
		}
	}

	Ok(Value::Object(Object(obj)))
}

pub fn is_empty((object,): (Object,)) -> Result<Value, Error> {
	Ok(Value::Bool(object.0.is_empty()))
}

pub fn len((object,): (Object,)) -> Result<Value, Error> {
	Ok(Value::from(object.len()))
}

pub fn keys((object,): (Object,)) -> Result<Value, Error> {
	Ok(Value::Array(Array(object.keys().map(|v| Value::Strand(Strand(v.to_owned()))).collect())))
}

pub fn values((object,): (Object,)) -> Result<Value, Error> {
	Ok(Value::Array(Array(object.values().map(|v| v.to_owned()).collect())))
}
use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::idx::planner::executor::QueryExecutor;
use crate::sql::value::TryRem;
use crate::sql::value::{TryAdd, TryDiv, TryMul, TryNeg, TryPow, TrySub, Value};
use crate::sql::{Expression, Thing};
use reblessive::tree::Stk;

pub fn neg(a: Value) -> Result<Value, Error> {
	a.try_neg()
}

pub fn not(a: Value) -> Result<Value, Error> {
	super::not::not((a,))
}

pub fn or(a: Value, b: Value) -> Result<Value, Error> {
	Ok(match a.is_truthy() {
		true => a,
		false => b,
	})
}

pub fn and(a: Value, b: Value) -> Result<Value, Error> {
	Ok(match a.is_truthy() {
		true => b,
		false => a,
	})
}

pub fn tco(a: Value, b: Value) -> Result<Value, Error> {
	Ok(match a.is_truthy() {
		true => a,
		false => b,
	})
}

pub fn nco(a: Value, b: Value) -> Result<Value, Error> {
	Ok(match a.is_some() {
		true => a,
		false => b,
	})
}

pub fn add(a: Value, b: Value) -> Result<Value, Error> {
	a.try_add(b)
}

pub fn sub(a: Value, b: Value) -> Result<Value, Error> {
	a.try_sub(b)
}

pub fn mul(a: Value, b: Value) -> Result<Value, Error> {
	a.try_mul(b)
}

pub fn div(a: Value, b: Value) -> Result<Value, Error> {
	Ok(a.try_div(b).unwrap_or(f64::NAN.into()))
}

pub fn rem(a: Value, b: Value) -> Result<Value, Error> {
	a.try_rem(b)
}

pub fn pow(a: Value, b: Value) -> Result<Value, Error> {
	a.try_pow(b)
}

pub fn exact(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(Value::from(a == b))
}

pub fn equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.equal(b).into())
}

pub fn not_equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!a.equal(b)).into())
}

pub fn all_equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.all_equal(b).into())
}

pub fn any_equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.any_equal(b).into())
}

pub fn like(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.fuzzy(b).into())
}

pub fn not_like(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!a.fuzzy(b)).into())
}

pub fn all_like(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.all_fuzzy(b).into())
}

pub fn any_like(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.any_fuzzy(b).into())
}

pub fn less_than(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.lt(b).into())
}

pub fn less_than_or_equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.le(b).into())
}

pub fn more_than(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.gt(b).into())
}

pub fn more_than_or_equal(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.ge(b).into())
}

pub fn contain(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.contains(b).into())
}

pub fn not_contain(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!a.contains(b)).into())
}

pub fn contain_all(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.contains_all(b).into())
}

pub fn contain_any(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.contains_any(b).into())
}

pub fn contain_none(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!a.contains_any(b)).into())
}

pub fn inside(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(b.contains(a).into())
}

pub fn not_inside(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!b.contains(a)).into())
}

pub fn inside_all(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(b.contains_all(a).into())
}

pub fn inside_any(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(b.contains_any(a).into())
}

pub fn inside_none(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!b.contains_any(a)).into())
}

pub fn outside(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok((!a.intersects(b)).into())
}

pub fn intersects(a: &Value, b: &Value) -> Result<Value, Error> {
	Ok(a.intersects(b).into())
}

enum ExecutorOption<'a> {
	PreMatch,
	None,
	Execute(&'a QueryExecutor, &'a Thing),
}

fn get_executor_and_thing<'a>(
	ctx: &'a Context,
	doc: &'a CursorDoc,
) -> Option<(&'a QueryExecutor, &'a Thing)> {
	if let Some(thg) = &doc.rid {
		if let Some(exe) = ctx.get_query_executor() {
			if exe.is_table(&thg.tb) {
				return Some((exe, thg.as_ref()));
			}
		}
		if let Some(pla) = ctx.get_query_planner() {
			if let Some(exe) = pla.get_query_executor(&thg.tb) {
				return Some((exe, thg));
			}
		}
	}
	None
}

fn get_executor_option<'a>(
	ctx: &'a Context,
	doc: Option<&'a CursorDoc>,
	exp: &'a Expression,
) -> ExecutorOption<'a> {
	if let Some(doc) = doc {
		if let Some((exe, thg)) = get_executor_and_thing(ctx, doc) {
			if let Some(ir) = &doc.ir {
				if exe.is_iterator_expression(ir.irf(), exp) {
					return ExecutorOption::PreMatch;
				}
			}
			return ExecutorOption::Execute(exe, thg);
		}
	}
	ExecutorOption::None
}

pub(crate) async fn matches(
	stk: &mut Stk,
	ctx: &Context,
	opt: &Options,
	doc: Option<&CursorDoc>,
	exp: &Expression,
	l: Value,
	r: Value,
) -> Result<Value, Error> {
	let res = match get_executor_option(ctx, doc, exp) {
		ExecutorOption::PreMatch => true,
		ExecutorOption::None => false,
		ExecutorOption::Execute(exe, thg) => exe.matches(stk, ctx, opt, thg, exp, l, r).await?,
	};
	Ok(res.into())
}

pub(crate) async fn knn(
	stk: &mut Stk,
	ctx: &Context,
	opt: &Options,
	doc: Option<&CursorDoc>,
	exp: &Expression,
) -> Result<Value, Error> {
	match get_executor_option(ctx, doc, exp) {
		ExecutorOption::PreMatch => Ok(Value::Bool(true)),
		ExecutorOption::None => Ok(Value::Bool(false)),
		ExecutorOption::Execute(exe, thg) => exe.knn(stk, ctx, opt, thg, doc, exp).await,
	}
}

#[cfg(test)]
mod tests {

	use super::*;

	#[test]
	fn or_true() {
		let one = Value::from(1);
		let two = Value::from(2);
		let res = or(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn or_false_one() {
		let one = Value::from(0);
		let two = Value::from(1);
		let res = or(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn or_false_two() {
		let one = Value::from(1);
		let two = Value::from(0);
		let res = or(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn and_true() {
		let one = Value::from(1);
		let two = Value::from(2);
		let res = and(one, two);
		let out = res.unwrap();
		assert_eq!("2", format!("{}", out));
	}

	#[test]
	fn and_false_one() {
		let one = Value::from(0);
		let two = Value::from(1);
		let res = and(one, two);
		let out = res.unwrap();
		assert_eq!("0", format!("{}", out));
	}

	#[test]
	fn and_false_two() {
		let one = Value::from(1);
		let two = Value::from(0);
		let res = and(one, two);
		let out = res.unwrap();
		assert_eq!("0", format!("{}", out));
	}

	#[test]
	fn tco_true() {
		let one = Value::from(1);
		let two = Value::from(2);
		let res = tco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn tco_false_one() {
		let one = Value::from(0);
		let two = Value::from(1);
		let res = tco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn tco_false_two() {
		let one = Value::from(1);
		let two = Value::from(0);
		let res = tco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn nco_true() {
		let one = Value::from(1);
		let two = Value::from(2);
		let res = nco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn nco_false_one() {
		let one = Value::None;
		let two = Value::from(1);
		let res = nco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn nco_false_two() {
		let one = Value::from(1);
		let two = Value::None;
		let res = nco(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn add_basic() {
		let one = Value::from(5);
		let two = Value::from(4);
		let res = add(one, two);
		let out = res.unwrap();
		assert_eq!("9", format!("{}", out));
	}

	#[test]
	fn sub_basic() {
		let one = Value::from(5);
		let two = Value::from(4);
		let res = sub(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn mul_basic() {
		let one = Value::from(5);
		let two = Value::from(4);
		let res = mul(one, two);
		let out = res.unwrap();
		assert_eq!("20", format!("{}", out));
	}

	#[test]
	fn div_int() {
		let one = Value::from(5);
		let two = Value::from(4);
		let res = div(one, two);
		let out = res.unwrap();
		assert_eq!("1", format!("{}", out));
	}

	#[test]
	fn div_float() {
		let one = Value::from(5.0);
		let two = Value::from(4.0);
		let res = div(one, two);
		let out = res.unwrap();
		assert_eq!("1.25f", format!("{}", out));
	}
}
pub mod email {

	use crate::err::Error;
	use crate::sql::value::Value;
	use addr::email::Host;

	pub fn host((string,): (String,)) -> Result<Value, Error> {
		// Parse the email address
		Ok(match addr::parse_email_address(&string) {
			// Return the host part
			Ok(v) => match v.host() {
				Host::Domain(name) => name.as_str().into(),
				Host::IpAddr(ip_addr) => ip_addr.to_string().into(),
			},
			Err(_) => Value::None,
		})
	}

	pub fn user((string,): (String,)) -> Result<Value, Error> {
		// Parse the email address
		Ok(match addr::parse_email_address(&string) {
			// Return the user part
			Ok(v) => v.user().into(),
			Err(_) => Value::None,
		})
	}

	#[cfg(test)]
	mod tests {
		#[test]
		fn host() {
			let input = (String::from("john.doe@example.com"),);
			let value = super::host(input).unwrap();
			assert_eq!(value, "example.com".into());
		}

		#[test]
		fn user() {
			let input = (String::from("john.doe@example.com"),);
			let value = super::user(input).unwrap();
			assert_eq!(value, "john.doe".into());
		}
	}
}

pub mod url {

	use crate::err::Error;
	use crate::sql::value::Value;
	use url::Url;

	pub fn domain((string,): (String,)) -> Result<Value, Error> {
		match Url::parse(&string) {
			Ok(v) => match v.domain() {
				Some(v) => Ok(v.into()),
				None => Ok(Value::None),
			},
			Err(_) => Ok(Value::None),
		}
	}

	pub fn fragment((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => match v.fragment() {
				Some(v) => Ok(v.into()),
				None => Ok(Value::None),
			},
			Err(_) => Ok(Value::None),
		}
	}

	pub fn host((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => match v.host_str() {
				Some(v) => Ok(v.into()),
				None => Ok(Value::None),
			},
			Err(_) => Ok(Value::None),
		}
	}

	pub fn path((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => Ok(v.path().into()),
			Err(_) => Ok(Value::None),
		}
	}

	pub fn port((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => match v.port_or_known_default() {
				Some(v) => Ok(v.into()),
				None => Ok(Value::None),
			},
			Err(_) => Ok(Value::None),
		}
	}

	pub fn query((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => match v.query() {
				Some(v) => Ok(v.into()),
				None => Ok(Value::None),
			},
			Err(_) => Ok(Value::None),
		}
	}

	pub fn scheme((string,): (String,)) -> Result<Value, Error> {
		// Parse the URL
		match Url::parse(&string) {
			Ok(v) => Ok(v.scheme().into()),
			Err(_) => Ok(Value::None),
		}
	}

	#[cfg(test)]
	mod tests {
		use crate::sql::value::Value;

		#[test]
		fn port_default_port_specified() {
			let value = super::port(("http://www.google.com:80".to_string(),)).unwrap();
			assert_eq!(value, 80.into());
		}

		#[test]
		fn port_nondefault_port_specified() {
			let value = super::port(("http://www.google.com:8080".to_string(),)).unwrap();
			assert_eq!(value, 8080.into());
		}

		#[test]
		fn port_no_port_specified() {
			let value = super::port(("http://www.google.com".to_string(),)).unwrap();
			assert_eq!(value, 80.into());
		}

		#[test]
		fn port_no_scheme_no_port_specified() {
			let value = super::port(("www.google.com".to_string(),)).unwrap();
			assert_eq!(value, Value::None);
		}
	}
}
use crate::cnf::ID_CHARS;
use crate::err::Error;
use crate::sql::uuid::Uuid;
use crate::sql::value::Value;
use crate::sql::{Datetime, Number};
use chrono::{TimeZone, Utc};
use nanoid::nanoid;
use rand::distributions::{Alphanumeric, DistString};
use rand::prelude::IteratorRandom;
use rand::Rng;
use ulid::Ulid;

pub fn rand(_: ()) -> Result<Value, Error> {
	Ok(rand::random::<f64>().into())
}

pub fn bool(_: ()) -> Result<Value, Error> {
	Ok(rand::random::<bool>().into())
}

pub fn r#enum(mut args: Vec<Value>) -> Result<Value, Error> {
	Ok(match args.len() {
		0 => Value::None,
		1 => match args.remove(0) {
			Value::Array(v) => v.into_iter().choose(&mut rand::thread_rng()).unwrap_or(Value::None),
			v => v,
		},
		_ => args.into_iter().choose(&mut rand::thread_rng()).unwrap(),
	})
}

// TODO (Delskayn): Don't agree with the inclusive ranges in the functions here,
// seems inconsistent with general use of ranges not including the upperbound.
// These should probably all be exclusive.
//
// TODO (Delskayn): Switching of min and max if min > max is also inconsistent with rest of
// functions and the range type. The functions should either return NONE or an error if the lowerbound
// of the ranges here are larger then the upperbound.
pub fn float((range,): (Option<(f64, f64)>,)) -> Result<Value, Error> {
	let res = if let Some((min, max)) = range {
		if max < min {
			rand::thread_rng().gen_range(max..=min)
		} else {
			rand::thread_rng().gen_range(min..=max)
		}
	} else {
		rand::random::<f64>()
	};
	Ok(res.into())
}

pub fn guid((arg1, arg2): (Option<i64>, Option<i64>)) -> Result<Value, Error> {
	// Set a reasonable maximum length
	const LIMIT: i64 = 64;

	// rand::guid(NULL,10) is not allowed by the calling infrastructure.
	let lower = arg1.unwrap_or(20);
	let len = if let Some(upper) = arg2 {
		if lower > upper {
			return Err(Error::InvalidArguments {
				name: String::from("rand::guid"),
				message: "Lowerbound of number of characters must be less then the upperbound."
					.to_string(),
			});
		}
		if upper > LIMIT {
			return Err(Error::InvalidArguments {
				name: String::from("rand::guid"),
				message: format!("To generate a string of X characters in length, the argument must be a positive number and no higher than {LIMIT}."),
			});
		}

		rand::thread_rng().gen_range((lower as usize)..=(upper as usize))
	} else {
		if lower > LIMIT {
			return Err(Error::InvalidArguments {
			name: String::from("rand::guid"),
			message: format!("To generate a string of X characters in length, the argument must be a positive number and no higher than {LIMIT}."),
		});
		}
		lower as usize
	};

	// Generate the random guid
	Ok(nanoid!(len, &ID_CHARS).into())
}

pub fn int((range,): (Option<(i64, i64)>,)) -> Result<Value, Error> {
	Ok(if let Some((min, max)) = range {
		if max < min {
			rand::thread_rng().gen_range(max..=min)
		} else {
			rand::thread_rng().gen_range(min..=max)
		}
	} else {
		rand::random::<i64>()
	}
	.into())
}

pub fn string((arg1, arg2): (Option<i64>, Option<i64>)) -> Result<Value, Error> {
	// Set a reasonable maximum length
	const LIMIT: i64 = 65536;
	// rand::guid(NULL,10) is not allowed by the calling infrastructure.
	let lower = arg1.unwrap_or(32);
	let len = if let Some(upper) = arg2 {
		if lower > upper {
			return Err(Error::InvalidArguments {
				name: String::from("rand::guid"),
				message: "Lowerbound of number of characters must be less then the upperbound."
					.to_string(),
			});
		}
		if upper > LIMIT {
			return Err(Error::InvalidArguments {
				name: String::from("rand::guid"),
				message: format!("To generate a string of X characters in length, the argument must be a positive number and no higher than {LIMIT}."),
			});
		}

		rand::thread_rng().gen_range((lower as usize)..=(upper as usize))
	} else {
		if lower > LIMIT {
			return Err(Error::InvalidArguments {
			name: String::from("rand::guid"),
			message: format!("To generate a string of X characters in length, the argument must be a positive number and no higher than {LIMIT}."),
		});
		}
		lower as usize
	};
	// Generate the random string
	Ok(Alphanumeric.sample_string(&mut rand::thread_rng(), len).into())
}

pub fn time((range,): (Option<(Value, Value)>,)) -> Result<Value, Error> {
	// Process the arguments
	let range = match range {
		None => None,
		Some((Value::Number(Number::Int(min)), Value::Number(Number::Int(max)))) => {
			Some((min, max))
		}
		Some((Value::Datetime(min), Value::Datetime(max))) => match (min.to_i64(), max.to_i64()) {
			(Some(min), Some(max)) => Some((min, max)),
			_ => {
				return Err(Error::InvalidArguments {
					name: String::from("rand::time"),
					message: String::from("Failed to convert datetime arguments to i64 timestamps"),
				})
			}
		},
		_ => {
			return Err(Error::InvalidArguments {
				name: String::from("rand::time"),
				message: String::from(
					"Expected an optional pair of datetimes or pair of i64 numbers to be passed",
				),
			})
		}
	};
	// Set the maximum valid seconds
	const LIMIT: i64 = 8210298412799;
	// Check the function input arguments
	let (min, max) = if let Some((min, max)) = range {
		match min {
			min if (1..=LIMIT).contains(&min) => match max {
				max if min <= max && max <= LIMIT => (min, max),
				max if max >= 1 && max <= min => (max, min),
				_ => return Err(Error::InvalidArguments {
					name: String::from("rand::time"),
					message: format!("To generate a time between X and Y seconds, the 2 arguments must be positive numbers and no higher than {LIMIT}."),
				}),
			},
			_ => return Err(Error::InvalidArguments {
				name: String::from("rand::time"),
				message: format!("To generate a time between X and Y seconds, the 2 arguments must be positive numbers and no higher than {LIMIT}."),
			}),
		}
	} else {
		(0, LIMIT)
	};
	// Generate the random time, try up to 5 times
	for _ in 0..5 {
		let val = rand::thread_rng().gen_range(min..=max);
		if let Some(v) = Utc.timestamp_opt(val, 0).earliest() {
			return Ok(v.into());
		}
	}
	// We were unable to generate a valid random datetime
	Err(fail!("Expected a valid datetime, but were unable to generate one"))
}

pub fn ulid((timestamp,): (Option<Datetime>,)) -> Result<Value, Error> {
	let ulid = match timestamp {
		Some(timestamp) => {
			#[cfg(target_family = "wasm")]
			if timestamp.0 < chrono::DateTime::UNIX_EPOCH {
				return Err(Error::InvalidArguments {
					name: String::from("rand::ulid"),
					message: format!(
						"To generate a ULID from a datetime, it must be a time beyond UNIX epoch."
					),
				});
			}

			Ulid::from_datetime(timestamp.0.into())
		}
		None => Ulid::new(),
	};

	Ok(ulid.to_string().into())
}

pub fn uuid((timestamp,): (Option<Datetime>,)) -> Result<Value, Error> {
	let uuid = match timestamp {
		Some(timestamp) => {
			#[cfg(target_family = "wasm")]
			if timestamp.0 < chrono::DateTime::UNIX_EPOCH {
				return Err(Error::InvalidArguments {
					name: String::from("rand::ulid"),
					message: format!(
						"To generate a ULID from a datetime, it must be a time beyond UNIX epoch."
					),
				});
			}

			Uuid::new_v7_from_datetime(timestamp)
		}
		None => Uuid::new(),
	};
	Ok(uuid.into())
}

pub mod uuid {

	use crate::err::Error;
	use crate::sql::uuid::Uuid;
	use crate::sql::value::Value;
	use crate::sql::Datetime;

	pub fn v4(_: ()) -> Result<Value, Error> {
		Ok(Uuid::new_v4().into())
	}

	pub fn v7((timestamp,): (Option<Datetime>,)) -> Result<Value, Error> {
		let uuid = match timestamp {
			Some(timestamp) => {
				#[cfg(target_family = "wasm")]
				if timestamp.0 < chrono::DateTime::UNIX_EPOCH {
					return Err(Error::InvalidArguments {
						name: String::from("rand::ulid"),
						message: format!(
							"To generate a ULID from a datetime, it must be a time beyond UNIX epoch."
						),
					});
				}

				Uuid::new_v7_from_datetime(timestamp)
			}
			None => Uuid::new(),
		};
		Ok(uuid.into())
	}
}
use crate::ctx::Context;
use crate::dbs::capabilities::ExperimentalTarget;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::sql::paths::ID;
use crate::sql::thing::Thing;
use crate::sql::value::Value;
use crate::sql::{Array, FlowResultExt as _, Idiom, Kind, Literal, Part, Table};
use reblessive::tree::Stk;

pub async fn exists(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(arg,): (Thing,),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		Ok(match Value::Thing(arg).get(stk, ctx, opt, doc, ID.as_ref()).await.catch_return()? {
			Value::None => Value::Bool(false),
			_ => Value::Bool(true),
		})
	} else {
		Ok(Value::None)
	}
}

pub fn id((arg,): (Thing,)) -> Result<Value, Error> {
	Ok(arg.id.into())
}

pub fn tb((arg,): (Thing,)) -> Result<Value, Error> {
	Ok(arg.tb.into())
}

pub async fn refs(
	(stk, ctx, opt, doc): (&mut Stk, &Context, &Options, Option<&CursorDoc>),
	(id, ft, ff): (Thing, Option<String>, Option<String>),
) -> Result<Value, Error> {
	if !ctx.get_capabilities().allows_experimental(&ExperimentalTarget::RecordReferences) {
		return Err(Error::InvalidFunction {
			name: "record::refs".to_string(),
			message: "Experimental feature is disabled".to_string(),
		});
	}

	// Process the inputs and make sure they are valid
	let ft = ft.map(Table::from);
	let ff = match ff {
		Some(ff) => Some(crate::syn::idiom(&ff)?),
		None => None,
	};

	// Check to see if the user is allowed to select the origin record id
	if exists((stk, ctx, Some(opt), doc), (id.clone(),)).await?.is_false() {
		return Ok(Value::Array(Array::default()));
	}

	// If both a table and a field are provided, attempt to correct the field if needed
	let ff = match (&ft, ff) {
		(Some(ft), Some(ff)) => Some(correct_refs_field(ctx, opt, ft, ff).await?),
		(_, ff) => ff,
	};

	// Get the references
	let ids = id.refs(ctx, opt, ft.as_ref(), ff.as_ref()).await?;
	// Convert the references into a value
	let val = ids.into_iter().map(Value::Thing).collect();

	Ok(Value::Array(val))
}

async fn correct_refs_field(
	ctx: &Context,
	opt: &Options,
	ft: &Table,
	ff: Idiom,
) -> Result<Idiom, Error> {
	// Obtain the field definition
	let (ns, db) = opt.ns_db()?;
	let fd = match ctx.tx().get_tb_field(ns, db, &ft.to_string(), &ff.to_string()).await {
		Ok(fd) => fd,
		// If the field does not exist, there is nothing to correct
		Err(Error::FdNotFound {
			..
		}) => return Ok(ff),
		Err(e) => return Err(e),
	};

	// Check if the field is an array-like value and thus "containing" references
	let is_contained = if let Some(kind) = &fd.kind {
		matches!(
			kind.non_optional(),
			Kind::Array(_, _) | Kind::Set(_, _) | Kind::Literal(Literal::Array(_))
		)
	} else {
		false
	};

	// If the field is an array-like value, add the `.*` part
	if is_contained {
		Ok(ff.push(Part::All))
	} else {
		Ok(ff)
	}
}
use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::fnc::get_execution_context;
use crate::idx::ft::analyzer::Analyzer;
use crate::idx::ft::highlighter::HighlightParams;
use crate::sql::Value;
use reblessive::tree::Stk;

pub async fn analyze(
	(stk, ctx, opt): (&mut Stk, &Context, Option<&Options>),
	(az, val): (Value, Value),
) -> Result<Value, Error> {
	if let (Some(opt), Value::Strand(az), Value::Strand(val)) = (opt, az, val) {
		let (ns, db) = opt.ns_db()?;
		let az = ctx.tx().get_db_analyzer(ns, db, &az).await?;
		let az = Analyzer::new(ctx.get_index_stores(), az)?;
		az.analyze(stk, ctx, opt, val.0).await
	} else {
		Ok(Value::None)
	}
}

pub async fn score(
	(ctx, doc): (&Context, Option<&CursorDoc>),
	(match_ref,): (Value,),
) -> Result<Value, Error> {
	if let Some((exe, doc, thg)) = get_execution_context(ctx, doc) {
		return exe.score(ctx, &match_ref, thg, doc.ir.as_ref()).await;
	}
	Ok(Value::None)
}

pub async fn highlight(
	(ctx, doc): (&Context, Option<&CursorDoc>),
	args: (Value, Value, Value, Option<Value>),
) -> Result<Value, Error> {
	if let Some((exe, doc, thg)) = get_execution_context(ctx, doc) {
		let hlp: HighlightParams = args.try_into()?;
		return exe.highlight(ctx, thg, hlp, doc.doc.as_ref()).await;
	}
	Ok(Value::None)
}

pub async fn offsets(
	(ctx, doc): (&Context, Option<&CursorDoc>),
	(match_ref, partial): (Value, Option<Value>),
) -> Result<Value, Error> {
	if let Some((exe, _, thg)) = get_execution_context(ctx, doc) {
		let partial = partial.map(|p| p.convert_to_bool()).unwrap_or(Ok(false))?;
		return exe.offsets(ctx, thg, match_ref, partial).await;
	}
	Ok(Value::None)
}
use crate::ctx::Context;
use crate::err::Error;
use crate::sql::paths::AC;
use crate::sql::paths::DB;
use crate::sql::paths::ID;
use crate::sql::paths::IP;
use crate::sql::paths::NS;
use crate::sql::paths::OR;
use crate::sql::paths::RD;
use crate::sql::paths::TK;
use crate::sql::value::Value;

pub fn ac(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(AC.as_ref()).ok()
}

pub fn db(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(DB.as_ref()).ok()
}

pub fn id(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(ID.as_ref()).ok()
}

pub fn ip(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(IP.as_ref()).ok()
}

pub fn ns(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(NS.as_ref()).ok()
}

pub fn origin(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(OR.as_ref()).ok()
}

pub fn rd(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(RD.as_ref()).ok()
}

pub fn token(ctx: &Context, _: ()) -> Result<Value, Error> {
	ctx.value("session").unwrap_or(&Value::None).pick(TK.as_ref()).ok()
}
use crate::ctx::Context;
use crate::err::Error;
use crate::sql::Duration;
use crate::sql::Value;

/// Sleep during the provided duration parameter.
pub async fn sleep(ctx: &Context, (dur,): (Duration,)) -> Result<Value, Error> {
	// Calculate the sleep duration
	let dur = match (ctx.timeout(), dur.0) {
		(Some(t), d) if t < d => t,
		(_, d) => d,
	};
	// Sleep for the specified time
	#[cfg(target_family = "wasm")]
	wasmtimer::tokio::sleep(dur).await;
	#[cfg(not(target_family = "wasm"))]
	tokio::time::sleep(dur).await;
	// Ok all good
	Ok(Value::None)
}
use crate::cnf::GENERATION_ALLOCATION_LIMIT;
use crate::err::Error;
use crate::fnc::util::string;
use crate::sql::value::Value;
use crate::sql::Regex;

/// Returns `true` if a string of this length is too much to allocate.
fn limit(name: &str, n: usize) -> Result<(), Error> {
	if n > *GENERATION_ALLOCATION_LIMIT {
		Err(Error::InvalidArguments {
			name: name.to_owned(),
			message: format!("Output must not exceed {} bytes.", *GENERATION_ALLOCATION_LIMIT),
		})
	} else {
		Ok(())
	}
}

pub fn concat(args: Vec<Value>) -> Result<Value, Error> {
	let strings = args.into_iter().map(Value::as_string).collect::<Vec<_>>();
	limit("string::concat", strings.iter().map(String::len).sum::<usize>())?;
	Ok(strings.concat().into())
}

pub fn contains((val, check): (String, String)) -> Result<Value, Error> {
	Ok(val.contains(&check).into())
}

pub fn ends_with((val, chr): (String, String)) -> Result<Value, Error> {
	Ok(val.ends_with(&chr).into())
}

pub fn join(args: Vec<Value>) -> Result<Value, Error> {
	let mut args = args.into_iter().map(Value::as_string);
	let chr = args.next().ok_or_else(|| Error::InvalidArguments {
		name: String::from("string::join"),
		message: String::from("Expected at least one argument"),
	})?;

	let strings = args.collect::<Vec<_>>();
	limit(
		"string::join",
		strings
			.len()
			.saturating_mul(chr.len())
			.saturating_add(strings.iter().map(String::len).sum::<usize>()),
	)?;

	// FIXME: Use intersperse to avoid intermediate allocation once stable
	// https://github.com/rust-lang/rust/issues/79524
	Ok(strings.join(&chr).into())
}

pub fn len((string,): (String,)) -> Result<Value, Error> {
	let num = string.chars().count() as i64;
	Ok(num.into())
}

pub fn lowercase((string,): (String,)) -> Result<Value, Error> {
	Ok(string.to_lowercase().into())
}

pub fn repeat((val, num): (String, usize)) -> Result<Value, Error> {
	limit("string::repeat", val.len().saturating_mul(num))?;
	Ok(val.repeat(num).into())
}

pub fn matches((val, regex): (String, Regex)) -> Result<Value, Error> {
	Ok(regex.0.is_match(&val).into())
}

pub fn replace((val, search, replace): (String, Value, String)) -> Result<Value, Error> {
	match search {
		Value::Strand(search) => {
			if replace.len() > search.len() {
				let increase = replace.len() - search.len();
				limit(
					"string::replace",
					val.len()
						.saturating_add(val.matches(&search.0).count().saturating_mul(increase)),
				)?;
			}
			Ok(val.replace(&search.0, &replace).into())
		}
		Value::Regex(search) => {
			let mut new_val = String::with_capacity(val.len());
			let mut last = 0;

			for m in search.0.find_iter(&val) {
				// Push everything until the match
				new_val.push_str(&val[last..m.start()]);

				// Push replacement
				new_val.push_str(&replace);

				// Abort early if we'd exceed the allowed limit
				limit("string::replace", new_val.len())?;

				last = m.end();
			}

			// Finally, push anything after the last match
			new_val.push_str(&val[last..]);
			limit("string::replace", new_val.len())?;
			Ok(new_val.into())
		}
		_ => Err(Error::InvalidArguments {
			name: "string::replace".to_string(),
			message: format!(
				"Argument 2 was the wrong type. Expected a string but found {}",
				search
			),
		}),
	}
}
pub fn reverse((string,): (String,)) -> Result<Value, Error> {
	Ok(string.chars().rev().collect::<String>().into())
}

pub fn slice((val, beg, lim): (String, Option<isize>, Option<isize>)) -> Result<Value, Error> {
	// Only count the chars if we need to and only do it once.
	let mut char_count = usize::MAX;
	let mut count_chars = || {
		if char_count == usize::MAX {
			char_count = val.chars().count();
		}
		char_count
	};

	let skip = match beg {
		Some(v) if v < 0 => count_chars().saturating_sub(v.unsigned_abs()),
		Some(v) => v as usize,
		None => 0,
	};

	let take = match lim {
		Some(v) if v < 0 => count_chars().saturating_sub(skip).saturating_sub(v.unsigned_abs()),
		Some(v) => v as usize,
		None => usize::MAX,
	};

	Ok(if skip > 0 || take < usize::MAX {
		val.chars().skip(skip).take(take).collect::<String>()
	} else {
		val
	}
	.into())
}

pub fn slug((string,): (String,)) -> Result<Value, Error> {
	Ok(string::slug::slug(string).into())
}

pub fn split((val, chr): (String, String)) -> Result<Value, Error> {
	Ok(val.split(&chr).collect::<Vec<&str>>().into())
}

pub fn starts_with((val, chr): (String, String)) -> Result<Value, Error> {
	Ok(val.starts_with(&chr).into())
}

pub fn trim((string,): (String,)) -> Result<Value, Error> {
	Ok(string.trim().into())
}

pub fn uppercase((string,): (String,)) -> Result<Value, Error> {
	Ok(string.to_uppercase().into())
}

pub fn words((string,): (String,)) -> Result<Value, Error> {
	Ok(string.split_whitespace().collect::<Vec<&str>>().into())
}

pub mod distance {

	use crate::err::Error;
	use crate::sql::Value;

	use strsim;

	/// Calculate the Damerau-Levenshtein distance between two strings
	/// via [`strsim::damerau_levenshtein`].
	pub fn damerau_levenshtein((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::damerau_levenshtein(&a, &b).into())
	}

	/// Calculate the normalized Damerau-Levenshtein distance between two strings
	/// via [`strsim::normalized_damerau_levenshtein`].
	pub fn normalized_damerau_levenshtein((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::normalized_damerau_levenshtein(&a, &b).into())
	}

	/// Calculate the Hamming distance between two strings
	/// via [`strsim::hamming`].
	///
	/// Will result in an [`Error::InvalidArguments`] if the given strings are of different lengths.
	pub fn hamming((a, b): (String, String)) -> Result<Value, Error> {
		match strsim::hamming(&a, &b) {
			Ok(v) => Ok(v.into()),
			Err(_) => Err(Error::InvalidArguments {
				name: "string::distance::hamming".into(),
				message: "Strings must be of equal length.".into(),
			}),
		}
	}

	/// Calculate the Levenshtein distance between two strings
	/// via [`strsim::levenshtein`].
	pub fn levenshtein((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::levenshtein(&a, &b).into())
	}

	/// Calculate the normalized Levenshtein distance between two strings
	/// via [`strsim::normalized_levenshtein`].
	pub fn normalized_levenshtein((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::normalized_levenshtein(&a, &b).into())
	}

	/// Calculate the OSA distance &ndash; a variant of the Levenshtein distance
	/// that allows for transposition of adjacent characters &ndash; between two strings
	/// via [`strsim::osa_distance`].
	pub fn osa_distance((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::osa_distance(&a, &b).into())
	}
}

pub mod html {
	use crate::err::Error;
	use crate::sql::value::Value;

	pub fn encode((arg,): (String,)) -> Result<Value, Error> {
		Ok(ammonia::clean_text(&arg).into())
	}

	pub fn sanitize((arg,): (String,)) -> Result<Value, Error> {
		Ok(ammonia::clean(&arg).into())
	}
}

pub mod is {
	use crate::err::Error;
	use crate::sql::value::Value;
	use crate::sql::{Datetime, Thing};
	use chrono::NaiveDateTime;
	use regex::Regex;
	use semver::Version;
	use std::char;
	use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
	use std::sync::LazyLock;
	use ulid::Ulid;
	use url::Url;
	use uuid::Uuid;

	#[rustfmt::skip] static LATITUDE_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new("^[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?)$").unwrap());
	#[rustfmt::skip] static LONGITUDE_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new("^[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?)$").unwrap());

	pub fn alphanum((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.chars().all(char::is_alphanumeric).into())
	}

	pub fn alpha((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.chars().all(char::is_alphabetic).into())
	}

	pub fn ascii((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.is_ascii().into())
	}

	pub fn datetime((arg, fmt): (String, Option<String>)) -> Result<Value, Error> {
		Ok(match fmt {
			Some(fmt) => NaiveDateTime::parse_from_str(&arg, &fmt).is_ok().into(),
			None => Datetime::try_from(arg.as_ref()).is_ok().into(),
		})
	}

	pub fn domain((arg,): (String,)) -> Result<Value, Error> {
		Ok(addr::parse_domain_name(arg.as_str()).is_ok().into())
	}

	pub fn email((arg,): (String,)) -> Result<Value, Error> {
		Ok(addr::parse_email_address(arg.as_str()).is_ok().into())
	}

	pub fn hexadecimal((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.chars().all(|x| char::is_ascii_hexdigit(&x)).into())
	}

	pub fn ip((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.parse::<IpAddr>().is_ok().into())
	}

	pub fn ipv4((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.parse::<Ipv4Addr>().is_ok().into())
	}

	pub fn ipv6((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.parse::<Ipv6Addr>().is_ok().into())
	}

	pub fn latitude((arg,): (String,)) -> Result<Value, Error> {
		Ok(LATITUDE_RE.is_match(arg.as_str()).into())
	}

	pub fn longitude((arg,): (String,)) -> Result<Value, Error> {
		Ok(LONGITUDE_RE.is_match(arg.as_str()).into())
	}

	pub fn numeric((arg,): (String,)) -> Result<Value, Error> {
		Ok(arg.chars().all(char::is_numeric).into())
	}

	pub fn semver((arg,): (String,)) -> Result<Value, Error> {
		Ok(Version::parse(arg.as_str()).is_ok().into())
	}

	pub fn url((arg,): (String,)) -> Result<Value, Error> {
		Ok(Url::parse(&arg).is_ok().into())
	}

	pub fn uuid((arg,): (String,)) -> Result<Value, Error> {
		Ok(Uuid::parse_str(arg.as_ref()).is_ok().into())
	}

	pub fn ulid((arg,): (String,)) -> Result<Value, Error> {
		Ok(Ulid::from_string(arg.as_ref()).is_ok().into())
	}

	pub fn record((arg, tb): (String, Option<Value>)) -> Result<Value, Error> {
		let res = match Thing::try_from(arg) {
			Ok(t) => match tb {
				Some(Value::Strand(tb)) => t.tb == *tb,
				Some(Value::Table(tb)) => t.tb == tb.0,
				Some(_) => {
					return Err(Error::InvalidArguments {
						name: "string::is::record()".into(),
						message:
							"Expected an optional string or table type for the second argument"
								.into(),
					})
				}
				None => true,
			},
			_ => false,
		};

		Ok(res.into())
	}
}

pub mod similarity {

	use crate::err::Error;
	use crate::fnc::util::string::fuzzy::Fuzzy;
	use crate::sql::Value;

	use strsim;

	pub fn fuzzy((a, b): (String, String)) -> Result<Value, Error> {
		Ok(a.as_str().fuzzy_score(b.as_str()).into())
	}

	/// Calculate the Jaro similarity between two strings
	/// via [`strsim::jaro`].
	pub fn jaro((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::jaro(&a, &b).into())
	}

	/// Calculate the Jaro-Winkler similarity between two strings
	/// via [`strsim::jaro_winkler`].
	pub fn jaro_winkler((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::jaro_winkler(&a, &b).into())
	}

	pub fn smithwaterman((a, b): (String, String)) -> Result<Value, Error> {
		Ok(a.as_str().fuzzy_score(b.as_str()).into())
	}

	/// Calculate the Sørensen-Dice similarity between two strings
	/// via [`strsim::sorensen_dice`].
	pub fn sorensen_dice((a, b): (String, String)) -> Result<Value, Error> {
		Ok(strsim::sorensen_dice(&a, &b).into())
	}
}

pub mod semver {

	use crate::err::Error;
	use crate::sql::Value;
	use semver::Version;

	fn parse_version(ver: &str, func: &str, msg: &str) -> Result<Version, Error> {
		Version::parse(ver).map_err(|_| Error::InvalidArguments {
			name: String::from(func),
			message: String::from(msg),
		})
	}

	pub fn compare((left, right): (String, String)) -> Result<Value, Error> {
		let left = parse_version(
			&left,
			"string::semver::compare",
			"Invalid semantic version string for left argument",
		)?;
		let right = parse_version(
			&right,
			"string::semver::compare",
			"Invalid semantic version string for right argument",
		)?;

		Ok((left.cmp(&right) as i32).into())
	}

	pub fn major((version,): (String,)) -> Result<Value, Error> {
		parse_version(&version, "string::semver::major", "Invalid semantic version")
			.map(|v| v.major.into())
	}

	pub fn minor((version,): (String,)) -> Result<Value, Error> {
		parse_version(&version, "string::semver::minor", "Invalid semantic version")
			.map(|v| v.minor.into())
	}

	pub fn patch((version,): (String,)) -> Result<Value, Error> {
		parse_version(&version, "string::semver::patch", "Invalid semantic version")
			.map(|v| v.patch.into())
	}

	pub mod inc {
		use crate::err::Error;
		use crate::fnc::string::semver::parse_version;
		use crate::sql::Value;

		pub fn major((version,): (String,)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::inc::major", "Invalid semantic version").map(
				|mut version| {
					version.major += 1;
					version.minor = 0;
					version.patch = 0;
					version.to_string().into()
				},
			)
		}

		pub fn minor((version,): (String,)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::inc::minor", "Invalid semantic version").map(
				|mut version| {
					version.minor += 1;
					version.patch = 0;
					version.to_string().into()
				},
			)
		}

		pub fn patch((version,): (String,)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::inc::patch", "Invalid semantic version").map(
				|mut version| {
					version.patch += 1;
					version.to_string().into()
				},
			)
		}
	}

	pub mod set {
		use crate::err::Error;
		use crate::fnc::string::semver::parse_version;
		use crate::sql::Value;

		pub fn major((version, value): (String, u64)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::set::major", "Invalid semantic version").map(
				|mut version| {
					version.major = value;
					version.to_string().into()
				},
			)
		}

		pub fn minor((version, value): (String, u64)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::set::minor", "Invalid semantic version").map(
				|mut version| {
					version.minor = value;
					version.to_string().into()
				},
			)
		}

		pub fn patch((version, value): (String, u64)) -> Result<Value, Error> {
			parse_version(&version, "string::semver::set::patch", "Invalid semantic version").map(
				|mut version| {
					version.patch = value;
					version.to_string().into()
				},
			)
		}
	}
}

#[cfg(test)]
mod tests {
	use super::{contains, matches, replace, slice};
	use crate::err::Error;
	use crate::sql::Value;

	#[test]
	fn string_slice() {
		fn test(initial: &str, beg: Option<isize>, end: Option<isize>, expected: &str) {
			assert_eq!(slice((initial.to_owned(), beg, end)).unwrap(), Value::from(expected));
		}

		let string = "abcdefg";
		test(string, None, None, string);
		test(string, Some(2), None, &string[2..]);
		test(string, Some(2), Some(3), &string[2..5]);
		test(string, Some(2), Some(-1), "cdef");
		test(string, Some(-2), None, "fg");
		test(string, Some(-4), Some(2), "de");
		test(string, Some(-4), Some(-1), "def");

		let string = "你好世界";
		test(string, None, None, string);
		test(string, Some(1), None, "好世界");
		test(string, Some(-1), None, "界");
		test(string, Some(-2), Some(1), "世");
	}

	#[test]
	fn string_contains() {
		fn test(base: &str, contained: &str, expected: bool) {
			assert_eq!(
				contains((base.to_string(), contained.to_string())).unwrap(),
				Value::from(expected)
			);
		}

		test("", "", true);
		test("", "a", false);
		test("a", "", true);
		test("abcde", "bcd", true);
		test("abcde", "cbcd", false);
		test("好世界", "世", true);
		test("好世界", "你好", false);
	}

	#[test]
	fn string_replace() {
		fn test(base: &str, pattern: Value, replacement: &str, expected: &str) {
			assert_eq!(
				replace((base.to_string(), pattern.clone(), replacement.to_string())).unwrap(),
				Value::from(expected),
				"replace({},{},{})",
				base,
				pattern,
				replacement
			);
		}

		test("foo bar", Value::Regex("foo".parse().unwrap()), "bar", "bar bar");
		test("foo bar", "bar".into(), "foo", "foo foo");
	}

	#[test]
	fn string_replace_limit() {
		let r = replace(("A".repeat(1000), Value::Regex("()".parse().unwrap()), "B".repeat(10000)));
		match r {
			Err(Error::InvalidArguments {
				name,
				message,
			}) => {
				assert_eq!(name, "string::replace");
				assert_eq!(message, "Output must not exceed 1048576 bytes.");
			}
			_ => panic!("Unexpected result: {:?}", r),
		}
	}

	#[test]
	fn string_matches() {
		fn test(base: &str, regex: &str, expected: bool) {
			assert_eq!(
				matches((base.to_string(), regex.parse().unwrap())).unwrap(),
				Value::from(expected),
				"matches({},{})",
				base,
				regex
			);
		}

		test("bar", "foo", false);
		test("", "foo", false);
		test("foo bar", "foo", true);
		test("foo bar", "bar", true);
	}

	#[test]
	fn is_alphanum() {
		let value = super::is::alphanum((String::from("abc123"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::alphanum((String::from("y%*"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_alpha() {
		let value = super::is::alpha((String::from("abc"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::alpha((String::from("1234"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_ascii() {
		let value = super::is::ascii((String::from("abc"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::ascii((String::from("中国"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_domain() {
		let value = super::is::domain((String::from("食狮.中国"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::domain((String::from("example-.com"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_email() {
		let input = (String::from("user@[fd79:cdcb:38cc:9dd:f686:e06d:32f3:c123]"),);
		let value = super::is::email(input).unwrap();
		assert_eq!(value, Value::Bool(true));

		let input = (String::from("john..doe@example.com"),);
		let value = super::is::email(input).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_hexadecimal() {
		let value = super::is::hexadecimal((String::from("00FF00"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::hexadecimal((String::from("SurrealDB"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_ip() {
		let value = super::is::ip((String::from("127.0.0.1"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::ip((String::from("127.0.0"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_ipv4() {
		let value = super::is::ipv4((String::from("127.0.0.1"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::ipv4((String::from("127.0.0"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_ipv6() {
		let value = super::is::ipv6((String::from("::1"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::ipv6((String::from("200t:db8::"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_latitude() {
		let value = super::is::latitude((String::from("-0.118092"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::latitude((String::from("12345"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_longitude() {
		let value = super::is::longitude((String::from("91.509865"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::longitude((String::from("-91.509865"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::longitude((String::from("-180.00000"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::longitude((String::from("-180.00001"),)).unwrap();
		assert_eq!(value, Value::Bool(false));

		let value = super::is::longitude((String::from("180.00000"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::longitude((String::from("180.00001"),)).unwrap();
		assert_eq!(value, Value::Bool(false));

		let value = super::is::longitude((String::from("12345"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_numeric() {
		let value = super::is::numeric((String::from("12345"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::numeric((String::from("abcde"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_semver() {
		let value = super::is::semver((String::from("1.0.0"),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::semver((String::from("1.0"),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn is_uuid() {
		let input = (String::from("123e4567-e89b-12d3-a456-426614174000"),);
		let value = super::is::uuid(input).unwrap();
		assert_eq!(value, Value::Bool(true));

		let input = (String::from("foo-bar"),);
		let value = super::is::uuid(input).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn html_encode() {
		let value = super::html::encode((String::from("<div>Hello world!</div>"),)).unwrap();
		assert_eq!(value, Value::Strand("&lt;div&gt;Hello&#32;world!&lt;&#47;div&gt;".into()));

		let value = super::html::encode((String::from("SurrealDB"),)).unwrap();
		assert_eq!(value, Value::Strand("SurrealDB".into()));
	}

	#[test]
	fn html_sanitize() {
		let value = super::html::sanitize((String::from("<div>Hello world!</div>"),)).unwrap();
		assert_eq!(value, Value::Strand("<div>Hello world!</div>".into()));

		let value = super::html::sanitize((String::from("XSS<script>attack</script>"),)).unwrap();
		assert_eq!(value, Value::Strand("XSS".into()));
	}

	#[test]
	fn semver_compare() {
		let value = super::semver::compare((String::from("1.2.3"), String::from("1.0.0"))).unwrap();
		assert_eq!(value, Value::from(1));

		let value = super::semver::compare((String::from("1.2.3"), String::from("1.2.3"))).unwrap();
		assert_eq!(value, Value::from(0));

		let value = super::semver::compare((String::from("1.0.0"), String::from("1.2.3"))).unwrap();
		assert_eq!(value, Value::from(-1));
	}

	#[test]
	fn semver_extract() {
		let value = super::semver::major((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from(1));

		let value = super::semver::minor((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from(2));

		let value = super::semver::patch((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from(3));
	}

	#[test]
	fn semver_increment() {
		let value = super::semver::inc::major((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from("2.0.0"));

		let value = super::semver::inc::minor((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from("1.3.0"));

		let value = super::semver::inc::patch((String::from("1.2.3"),)).unwrap();
		assert_eq!(value, Value::from("1.2.4"));
	}

	#[test]
	fn semver_set() {
		let value = super::semver::set::major((String::from("1.2.3"), 9)).unwrap();
		assert_eq!(value, Value::from("9.2.3"));

		let value = super::semver::set::minor((String::from("1.2.3"), 9)).unwrap();
		assert_eq!(value, Value::from("1.9.3"));

		let value = super::semver::set::patch((String::from("1.2.3"), 9)).unwrap();
		assert_eq!(value, Value::from("1.2.9"));
	}
}
use crate::err::Error;
use crate::sql::datetime::Datetime;
use crate::sql::duration::Duration;
use crate::sql::value::Value;
use chrono::offset::TimeZone;
use chrono::{DateTime, Datelike, DurationRound, Local, Timelike, Utc};

pub fn ceil((val, duration): (Datetime, Duration)) -> Result<Value, Error> {
	match chrono::Duration::from_std(*duration) {
		Ok(d) => {
			let floor_to_ceil = |floor: DateTime<Utc>| -> Option<DateTime<Utc>> {
				if floor == *val {
					Some(floor)
				} else {
					floor.checked_add_signed(d)
				}
			};
			// Check for zero duration.
			if d.is_zero() {
				return Ok(Value::Datetime(val));
			}
			let result = val
				.duration_trunc(d)
				.ok()
				.and_then(floor_to_ceil);

			match result {
				Some(v) => Ok(v.into()),
				_ => Err(Error::InvalidArguments {
					name: String::from("time::ceil"),
					message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
				}),
			}
		},
		_ => Err(Error::InvalidArguments {
			name: String::from("time::ceil"),
			message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
		}),
	}
}

pub fn day((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.day().into(),
		None => Datetime::default().day().into(),
	})
}

pub fn floor((val, duration): (Datetime, Duration)) -> Result<Value, Error> {
	match chrono::Duration::from_std(*duration) {
		Ok(d) => {
			// Check for zero duration
			if d.is_zero() {
				return Ok(Value::Datetime(val));
			}
			match val.duration_trunc(d){
				Ok(v) => Ok(v.into()),
				_ => Err(Error::InvalidArguments {
					name: String::from("time::floor"),
					message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
				}),
			}
		},
		_ => Err(Error::InvalidArguments {
			name: String::from("time::floor"),
			message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
		}),
	}
}

pub fn format((val, format): (Datetime, String)) -> Result<Value, Error> {
	Ok(val.format(&format).to_string().into())
}

pub fn group((val, group): (Datetime, String)) -> Result<Value, Error> {
	match group.as_str() {
		"year" => Ok(Utc
			.with_ymd_and_hms(val.year(), 1, 1, 0,0,0)
			.earliest()
			.unwrap()
			.into()),
		"month" => Ok(Utc
			.with_ymd_and_hms(val.year(), val.month(), 1, 0,0,0)
			.earliest()
			.unwrap()
			.into()),
		"day" => Ok(Utc
			.with_ymd_and_hms(val.year(), val.month(), val.day(), 0,0,0)
			.earliest()
			.unwrap()
			.into()),
		"hour" => Ok(Utc
			.with_ymd_and_hms(val.year(), val.month(), val.day(), val.hour(),0,0)
			.earliest()
			.unwrap()
			.into()),
		"minute" => Ok(Utc
			.with_ymd_and_hms(val.year(), val.month(), val.day(), val.hour(), val.minute(),0)
			.earliest()
			.unwrap()
			.into()),
		"second" => Ok(Utc
			.with_ymd_and_hms(val.year(), val.month(), val.day(), val.hour(), val.minute(), val.second())
			.earliest()
			.unwrap()
			.into()),
		_ => Err(Error::InvalidArguments {
			name: String::from("time::group"),
			message: String::from("The second argument must be a string, and can be one of 'year', 'month', 'day', 'hour', 'minute', or 'second'."),
		}),
	}
}

pub fn hour((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.hour().into(),
		None => Datetime::default().hour().into(),
	})
}

pub fn max((array,): (Vec<Datetime>,)) -> Result<Value, Error> {
	Ok(match array.into_iter().max() {
		Some(v) => v.into(),
		None => Value::None,
	})
}

pub fn min((array,): (Vec<Datetime>,)) -> Result<Value, Error> {
	Ok(match array.into_iter().min() {
		Some(v) => v.into(),
		None => Value::None,
	})
}

pub fn minute((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.minute().into(),
		None => Datetime::default().minute().into(),
	})
}

pub fn month((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.month().into(),
		None => Datetime::default().month().into(),
	})
}

pub fn nano((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.timestamp_nanos_opt().unwrap_or_default().into(),
		None => Datetime::default().timestamp_nanos_opt().unwrap_or_default().into(),
	})
}

pub fn millis((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.timestamp_millis().into(),
		None => Datetime::default().timestamp_millis().into(),
	})
}

pub fn micros((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.timestamp_micros().into(),
		None => Datetime::default().timestamp_micros().into(),
	})
}

pub fn now(_: ()) -> Result<Value, Error> {
	Ok(Datetime::default().into())
}

pub fn round((val, duration): (Datetime, Duration)) -> Result<Value, Error> {
	match chrono::Duration::from_std(*duration) {
		Ok(d) => {
			// Check for zero duration
			if d.is_zero() {
				return Ok(Value::Datetime(val));
			}
			match val.duration_round(d) {
				Ok(v) => Ok(v.into()),
				_ => Err(Error::InvalidArguments {
					name: String::from("time::round"),
					message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
				}),
			}
		},
		_ => Err(Error::InvalidArguments {
			name: String::from("time::round"),
			message: String::from("The second argument must be a duration, and must be able to be represented as nanoseconds."),
		}),
	}
}

pub fn second((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.second().into(),
		None => Datetime::default().second().into(),
	})
}

pub fn timezone(_: ()) -> Result<Value, Error> {
	Ok(Local::now().offset().to_string().into())
}

pub fn unix((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.timestamp().into(),
		None => Datetime::default().timestamp().into(),
	})
}

pub fn wday((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.weekday().number_from_monday().into(),
		None => Datetime::default().weekday().number_from_monday().into(),
	})
}

pub fn week((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.iso_week().week().into(),
		None => Datetime::default().iso_week().week().into(),
	})
}

pub fn yday((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.ordinal().into(),
		None => Datetime::default().ordinal().into(),
	})
}

pub fn year((val,): (Option<Datetime>,)) -> Result<Value, Error> {
	Ok(match val {
		Some(v) => v.year().into(),
		None => Datetime::default().year().into(),
	})
}

pub mod is {
	use crate::err::Error;
	use crate::sql::{Datetime, Value};

	pub fn leap_year((val,): (Option<Datetime>,)) -> Result<Value, Error> {
		Ok(match val {
			Some(v) => v.naive_utc().date().leap_year().into(),
			None => Datetime::default().naive_utc().date().leap_year().into(),
		})
	}
}

pub mod from {

	use crate::err::Error;
	use crate::sql::datetime::Datetime;
	use crate::sql::{value::Value, Uuid};
	use chrono::DateTime;
	use ulid::Ulid;

	pub fn nanos((val,): (i64,)) -> Result<Value, Error> {
		const NANOS_PER_SEC: i64 = 1_000_000_000;

		let seconds = val.div_euclid(NANOS_PER_SEC);
		let nanoseconds = val.rem_euclid(NANOS_PER_SEC) as u32;

		match DateTime::from_timestamp(seconds, nanoseconds) {
			Some(v) => Ok(Datetime::from(v).into()),
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::nanos"),
				message: String::from("The first argument must be an in-bounds number of nanoseconds relative to January 1, 1970 0:00:00 UTC."),
			}),
		}
	}

	pub fn micros((val,): (i64,)) -> Result<Value, Error> {
		match DateTime::from_timestamp_micros(val) {
			Some(v) => Ok(Datetime::from(v).into()),
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::micros"),
				message: String::from("The first argument must be an in-bounds number of microseconds relative to January 1, 1970 0:00:00 UTC."),
			}),
		}
	}

	pub fn millis((val,): (i64,)) -> Result<Value, Error> {
		match DateTime::from_timestamp_millis(val) {
			Some(v) => Ok(Datetime::from(v).into()),
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::millis"),
				message: String::from("The first argument must be an in-bounds number of milliseconds relative to January 1, 1970 0:00:00 UTC."),
			}),
		}
	}

	pub fn secs((val,): (i64,)) -> Result<Value, Error> {
		match DateTime::from_timestamp(val, 0) {
			Some(v) => Ok(Datetime::from(v).into()),
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::secs"),
				message: String::from("The first argument must be an in-bounds number of seconds relative to January 1, 1970 0:00:00 UTC."),
			}),
		}
	}

	pub fn unix((val,): (i64,)) -> Result<Value, Error> {
		match DateTime::from_timestamp(val, 0) {
			Some(v) => Ok(Datetime::from(v).into()),
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::unix"),
				message: String::from("The first argument must be an in-bounds number of seconds relative to January 1, 1970 0:00:00 UTC."),
			}),
		}
	}

	pub fn ulid((val,): (String,)) -> Result<Value, Error> {
		match Ulid::from_string(&val) {
			Ok(v) => Ok(Datetime::from(DateTime::from(v.datetime())).into()),
			_ => Err(Error::InvalidArguments {
				name: String::from("time::from::ulid"),
				message: String::from(
					"The first argument must be a string, containing a valid ULID.",
				),
			}),
		}
	}

	pub fn uuid((val,): (Uuid,)) -> Result<Value, Error> {
		match val.0.get_timestamp() {
			Some(v) => {
				let (s, ns) = v.to_unix();
				match Datetime::try_from((s as i64, ns)) {
					Ok(v) => Ok(v.into()),
					_ => Err(fail!("Failed to convert UUID Timestamp to Datetime.")),
				}
			}
			None => Err(Error::InvalidArguments {
				name: String::from("time::from::uuid"),
				message: String::from("The first argument must be a v1, v6 or v7 UUID."),
			}),
		}
	}
}
use std::ops::Deref;

use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::sql::table::Table;
use crate::sql::thing::Thing;
use crate::sql::value::Value;
use crate::sql::{File, FlowResultExt as _, Kind, Strand};
use crate::syn;
use reblessive::tree::Stk;

pub fn array((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_array().map(Value::from)
}

pub fn bool((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_bool().map(Value::from)
}

pub fn file((bucket, key): (String, String)) -> Result<Value, Error> {
	Ok(Value::File(File::new(bucket, key)))
}

pub fn bytes((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_bytes().map(Value::from)
}

pub fn datetime((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_datetime().map(Value::from)
}

pub fn decimal((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_decimal().map(Value::from)
}

pub fn duration((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_duration().map(Value::from)
}

pub async fn field(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(val,): (String,),
) -> Result<Value, Error> {
	match opt {
		Some(opt) => {
			// Parse the string as an Idiom
			let idi = syn::idiom(&val)?;
			// Return the Idiom or fetch the field
			idi.compute(stk, ctx, opt, doc).await.catch_return()
		}
		_ => Ok(Value::None),
	}
}

pub async fn fields(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(val,): (Vec<String>,),
) -> Result<Value, Error> {
	match opt {
		Some(opt) => {
			let mut args: Vec<Value> = Vec::with_capacity(val.len());
			for v in val {
				// Parse the string as an Idiom
				let idi = syn::idiom(&v)?;
				// Return the Idiom or fetch the field
				args.push(idi.compute(stk, ctx, opt, doc).await.catch_return()?);
			}
			Ok(args.into())
		}
		_ => Ok(Value::None),
	}
}

pub fn float((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_float().map(Value::from)
}

pub fn geometry((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_geometry().map(Value::from)
}

pub fn int((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_int().map(Value::from)
}

pub fn number((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_number().map(Value::from)
}

pub fn point((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_point().map(Value::from)
}

pub fn range((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_range().map(Value::from)
}

pub fn record((rid, tb): (Value, Option<Value>)) -> Result<Value, Error> {
	match tb {
		Some(Value::Strand(Strand(tb)) | Value::Table(Table(tb))) if tb.is_empty() => {
			Err(Error::TbInvalid {
				value: tb,
			})
		}
		Some(Value::Strand(Strand(tb)) | Value::Table(Table(tb))) => {
			rid.convert_to(&Kind::Record(vec![tb.into()]))
		}
		Some(_) => Err(Error::InvalidArguments {
			name: "type::record".into(),
			message: "The second argument must be a table name or a string.".into(),
		}),
		None => rid.convert_to(&Kind::Record(vec![])),
	}
}

pub fn string((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_strand().map(Value::from)
}

pub fn string_lossy((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_strand_lossy().map(Value::from)
}

pub fn table((val,): (Value,)) -> Result<Value, Error> {
	Ok(Value::Table(Table(match val {
		Value::Thing(t) => t.tb,
		v => v.as_string(),
	})))
}

pub fn thing((arg1, arg2): (Value, Option<Value>)) -> Result<Value, Error> {
	match (arg1, arg2) {
		// Empty table name
		(Value::Strand(arg1), _) if arg1.is_empty() => Err(Error::TbInvalid {
			value: arg1.as_string(),
		}),

		// Empty ID part
		(_, Some(Value::Strand(arg2))) if arg2.is_empty() => Err(Error::IdInvalid {
			value: arg2.as_string(),
		}),

		// Handle second argument
		(arg1, Some(arg2)) => Ok(Value::Thing(Thing {
			tb: arg1.as_string(),
			id: match arg2 {
				Value::Thing(v) => v.id,
				Value::Array(v) => v.into(),
				Value::Object(v) => v.into(),
				Value::Number(v) => v.into(),
				Value::Range(v) => v.deref().to_owned().try_into()?,
				v => v.as_string().into(),
			},
		})),

		// No second argument passed
		(arg1, _) => Ok(match arg1 {
			Value::Thing(v) => Ok(v),
			Value::Strand(v) => Thing::try_from(v.as_str()).map_err(move |_| Error::ConvertTo {
				from: Value::Strand(v),
				into: "record".into(),
			}),
			v => Err(Error::ConvertTo {
				from: v,
				into: "record".into(),
			}),
		}?
		.into()),
	}
}

pub fn uuid((val,): (Value,)) -> Result<Value, Error> {
	val.convert_to_uuid().map(Value::from)
}

pub mod is {
	use crate::err::Error;
	use crate::sql::table::Table;
	use crate::sql::value::Value;
	use crate::sql::Geometry;

	pub fn array((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_array().into())
	}

	pub fn bool((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_bool().into())
	}

	pub fn bytes((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_bytes().into())
	}

	pub fn collection((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::Collection(_))).into())
	}

	pub fn datetime((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_datetime().into())
	}

	pub fn decimal((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_decimal().into())
	}

	pub fn duration((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_duration().into())
	}

	pub fn float((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_float().into())
	}

	pub fn geometry((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_geometry().into())
	}

	pub fn int((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_int().into())
	}

	pub fn line((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::Line(_))).into())
	}

	pub fn none((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_none().into())
	}

	pub fn null((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_null().into())
	}

	pub fn multiline((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::MultiLine(_))).into())
	}

	pub fn multipoint((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::MultiPoint(_))).into())
	}

	pub fn multipolygon((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::MultiPolygon(_))).into())
	}

	pub fn number((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_number().into())
	}

	pub fn object((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_object().into())
	}

	pub fn point((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::Point(_))).into())
	}

	pub fn polygon((arg,): (Value,)) -> Result<Value, Error> {
		Ok(matches!(arg, Value::Geometry(Geometry::Polygon(_))).into())
	}

	pub fn range((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_range().into())
	}

	pub fn record((arg, table): (Value, Option<String>)) -> Result<Value, Error> {
		Ok(match table {
			Some(tb) => arg.is_record_type(&[Table(tb)]).into(),
			None => arg.is_record().into(),
		})
	}

	pub fn string((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_strand().into())
	}

	pub fn uuid((arg,): (Value,)) -> Result<Value, Error> {
		Ok(arg.is_uuid().into())
	}
}

#[cfg(test)]
mod tests {
	use crate::err::Error;
	use crate::sql::value::Value;

	#[test]
	fn is_array() {
		let value = super::is::array((vec!["hello", "world"].into(),)).unwrap();
		assert_eq!(value, Value::Bool(true));

		let value = super::is::array(("test".into(),)).unwrap();
		assert_eq!(value, Value::Bool(false));
	}

	#[test]
	fn no_empty_thing() {
		let value = super::thing(("".into(), None));
		let _expected = Error::TbInvalid {
			value: "".into(),
		};
		if !matches!(value, Err(_expected)) {
			panic!("An empty thing tb part should result in an error");
		}

		let value = super::thing(("table".into(), Some("".into())));
		let _expected = Error::IdInvalid {
			value: "".into(),
		};
		if !matches!(value, Err(_expected)) {
			panic!("An empty thing id part should result in an error");
		}
	}
}
use crate::ctx::Context;
use crate::dbs::Options;
use crate::doc::CursorDoc;
use crate::err::Error;
use crate::sql::idiom::Idiom;
use crate::sql::value::Value;
use crate::sql::{Closure, FlowResultExt as _, Function};
use reblessive::tree::Stk;

pub async fn chain(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(value, worker): (Value, Closure),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		//TODO: Call directly on closure
		let fnc = Function::Anonymous(worker.into(), vec![value], false);
		fnc.compute(stk, ctx, opt, doc).await.catch_return()
	} else {
		Ok(Value::None)
	}
}

pub async fn diff(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(val1, val2): (Value, Value),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		let val1 = val1.compute(stk, ctx, opt, doc).await.catch_return()?;
		let val2 = val2.compute(stk, ctx, opt, doc).await.catch_return()?;
		Ok(val1.diff(&val2, Idiom::default()).into())
	} else {
		Ok(Value::None)
	}
}

pub async fn patch(
	(stk, ctx, opt, doc): (&mut Stk, &Context, Option<&Options>, Option<&CursorDoc>),
	(val, diff): (Value, Value),
) -> Result<Value, Error> {
	if let Some(opt) = opt {
		let mut val = val.compute(stk, ctx, opt, doc).await.catch_return()?;
		val.patch(diff)?;
		Ok(val)
	} else {
		Ok(Value::None)
	}
}
use crate::err::Error;
use crate::fnc::util::math::vector::{
	Add, Angle, CrossProduct, Divide, DotProduct, Magnitude, Multiply, Normalize, Project, Scale,
	Subtract,
};
use crate::sql::{Number, Value};

pub fn add((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.add(&b)?.into())
}

pub fn angle((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.angle(&b)?.into())
}

pub fn divide((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.divide(&b)?.into())
}

pub fn cross((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.cross(&b)?.into())
}

pub fn dot((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.dot(&b)?.into())
}

pub fn magnitude((a,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(a.magnitude().into())
}

pub fn multiply((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.multiply(&b)?.into())
}

pub fn normalize((a,): (Vec<Number>,)) -> Result<Value, Error> {
	Ok(a.normalize().into())
}

pub fn project((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.project(&b)?.into())
}

pub fn subtract((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
	Ok(a.subtract(&b)?.into())
}

pub fn scale((a, b): (Vec<Number>, Number)) -> Result<Value, Error> {
	Ok(a.scale(&b)?.into())
}

pub mod distance {
	use crate::ctx::Context;
	use crate::doc::CursorDoc;
	use crate::err::Error;
	use crate::fnc::get_execution_context;
	use crate::fnc::util::math::vector::{
		ChebyshevDistance, EuclideanDistance, HammingDistance, ManhattanDistance, MinkowskiDistance,
	};
	use crate::idx::planner::IterationStage;
	use crate::sql::{Number, Value};

	pub fn chebyshev((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.chebyshev_distance(&b)?.into())
	}

	pub fn euclidean((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.euclidean_distance(&b)?.into())
	}

	pub fn hamming((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.hamming_distance(&b)?.into())
	}

	pub fn knn(
		(ctx, doc): (&Context, Option<&CursorDoc>),
		(knn_ref,): (Option<Value>,),
	) -> Result<Value, Error> {
		if let Some((_exe, doc, thg)) = get_execution_context(ctx, doc) {
			if let Some(ir) = &doc.ir {
				if let Some(d) = ir.dist() {
					return Ok(d.into());
				}
			}
			if let Some(IterationStage::Iterate(Some(results))) = ctx.get_iteration_stage() {
				let n = if let Some(Value::Number(n)) = knn_ref {
					n.as_usize()
				} else {
					0
				};
				if let Some(d) = results.get_dist(n, thg) {
					return Ok(d.into());
				}
			}
		}
		Ok(Value::None)
	}

	pub fn mahalanobis((_, _): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Err(Error::FeatureNotYetImplemented {
			feature: "vector::distance::mahalanobis() function".to_string(),
		})
	}

	pub fn manhattan((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.manhattan_distance(&b)?.into())
	}

	pub fn minkowski((a, b, o): (Vec<Number>, Vec<Number>, Number)) -> Result<Value, Error> {
		Ok(a.minkowski_distance(&b, &o)?.into())
	}
}

pub mod similarity {

	use crate::err::Error;
	use crate::fnc::util::math::vector::{CosineSimilarity, JaccardSimilarity, PearsonSimilarity};
	use crate::sql::{Number, Value};

	pub fn cosine((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.cosine_similarity(&b)?.into())
	}

	pub fn jaccard((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.jaccard_similarity(&b)?.into())
	}

	pub fn pearson((a, b): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Ok(a.pearson_similarity(&b)?.into())
	}

	pub fn spearman((_, _): (Vec<Number>, Vec<Number>)) -> Result<Value, Error> {
		Err(Error::FeatureNotYetImplemented {
			feature: "vector::similarity::spearman() function".to_string(),
		})
	}
}

impl TryFrom<&Value> for Vec<Number> {
	type Error = Error;

	fn try_from(val: &Value) -> Result<Self, Self::Error> {
		if let Value::Array(a) = val {
			a.iter()
				.map(|v| v.try_into())
				.collect::<Result<Self, Error>>()
				.map_err(|e| Error::InvalidVectorValue(e.to_string()))
		} else {
			Err(Error::InvalidVectorValue(val.to_string()))
		}
	}
}

impl TryFrom<Value> for Vec<Number> {
	type Error = Error;

	fn try_from(val: Value) -> Result<Self, Self::Error> {
		if let Value::Array(a) = val {
			a.into_iter()
				.map(Value::try_into)
				.collect::<Result<Self, Error>>()
				.map_err(|e| Error::InvalidVectorValue(e.to_string()))
		} else {
			Err(Error::InvalidVectorValue(val.to_string()))
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::sql::Number;
	use rust_decimal::Decimal;

	#[test]
	fn vector_scale_int() {
		let input_vector: Vec<Number> = vec![1, 2, 3, 4].into_iter().map(Number::Int).collect();
		let scalar_int = Number::Int(2);

		let result: Result<Value, Error> = scale((input_vector.clone(), scalar_int));

		let expected_output: Vec<Number> = vec![2, 4, 6, 8].into_iter().map(Number::Int).collect();

		assert_eq!(result.unwrap(), expected_output.into());
	}

	#[test]
	fn vector_scale_float() {
		let input_vector: Vec<Number> = vec![1, 2, 3, 4].into_iter().map(Number::Int).collect();
		let scalar_float = Number::Float(1.51);

		let result: Result<Value, Error> = scale((input_vector.clone(), scalar_float));
		let expected_output: Vec<Number> =
			vec![1.51, 3.02, 4.53, 6.04].into_iter().map(Number::Float).collect();
		assert_eq!(result.unwrap(), expected_output.into());
	}

	#[test]
	fn vector_scale_decimal() {
		let input_vector: Vec<Number> = vec![1, 2, 3, 4].into_iter().map(Number::Int).collect();
		let scalar_decimal = Number::Decimal(Decimal::new(3141, 3));

		let result: Result<Value, Error> = scale((input_vector.clone(), scalar_decimal));
		let expected_output: Vec<Number> = vec![
			Number::Decimal(Decimal::new(3141, 3)),  // 3.141 * 1
			Number::Decimal(Decimal::new(6282, 3)),  // 3.141 * 2
			Number::Decimal(Decimal::new(9423, 3)),  // 3.141 * 3
			Number::Decimal(Decimal::new(12564, 3)), // 3.141 * 4
		];
		assert_eq!(result.unwrap(), expected_output.into());
	}
}
